"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yup";
exports.ids = ["vendor-chunks/yup"];
exports.modules = {

/***/ "(ssr)/./node_modules/yup/index.esm.js":
/*!***************************************!*\
  !*** ./node_modules/yup/index.esm.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArraySchema: () => (/* binding */ ArraySchema),\n/* harmony export */   BooleanSchema: () => (/* binding */ BooleanSchema),\n/* harmony export */   DateSchema: () => (/* binding */ DateSchema),\n/* harmony export */   LazySchema: () => (/* binding */ Lazy),\n/* harmony export */   MixedSchema: () => (/* binding */ MixedSchema),\n/* harmony export */   NumberSchema: () => (/* binding */ NumberSchema),\n/* harmony export */   ObjectSchema: () => (/* binding */ ObjectSchema),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   StringSchema: () => (/* binding */ StringSchema),\n/* harmony export */   TupleSchema: () => (/* binding */ TupleSchema),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   addMethod: () => (/* binding */ addMethod),\n/* harmony export */   array: () => (/* binding */ create$2),\n/* harmony export */   bool: () => (/* binding */ create$7),\n/* harmony export */   boolean: () => (/* binding */ create$7),\n/* harmony export */   date: () => (/* binding */ create$4),\n/* harmony export */   defaultLocale: () => (/* binding */ locale),\n/* harmony export */   getIn: () => (/* binding */ getIn),\n/* harmony export */   isSchema: () => (/* binding */ isSchema),\n/* harmony export */   lazy: () => (/* binding */ create),\n/* harmony export */   mixed: () => (/* binding */ create$8),\n/* harmony export */   number: () => (/* binding */ create$5),\n/* harmony export */   object: () => (/* binding */ create$3),\n/* harmony export */   printValue: () => (/* binding */ printValue),\n/* harmony export */   reach: () => (/* binding */ reach),\n/* harmony export */   ref: () => (/* binding */ create$9),\n/* harmony export */   setLocale: () => (/* binding */ setLocale),\n/* harmony export */   string: () => (/* binding */ create$6),\n/* harmony export */   tuple: () => (/* binding */ create$1)\n/* harmony export */ });\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-expr */ \"(ssr)/./node_modules/property-expr/index.js\");\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-case */ \"(ssr)/./node_modules/tiny-case/index.js\");\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toposort */ \"(ssr)/./node_modules/toposort/index.js\");\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== \"undefined\" ? Symbol.prototype.toString : ()=>\"\";\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n    if (val != +val) return \"NaN\";\n    const isNegativeZero = val === 0 && 1 / val < 0;\n    return isNegativeZero ? \"-0\" : \"\" + val;\n}\nfunction printSimpleValue(val, quoteStrings = false) {\n    if (val == null || val === true || val === false) return \"\" + val;\n    const typeOf = typeof val;\n    if (typeOf === \"number\") return printNumber(val);\n    if (typeOf === \"string\") return quoteStrings ? `\"${val}\"` : val;\n    if (typeOf === \"function\") return \"[Function \" + (val.name || \"anonymous\") + \"]\";\n    if (typeOf === \"symbol\") return symbolToString.call(val).replace(SYMBOL_REGEXP, \"Symbol($1)\");\n    const tag = toString.call(val).slice(8, -1);\n    if (tag === \"Date\") return isNaN(val.getTime()) ? \"\" + val : val.toISOString(val);\n    if (tag === \"Error\" || val instanceof Error) return \"[\" + errorToString.call(val) + \"]\";\n    if (tag === \"RegExp\") return regExpToString.call(val);\n    return null;\n}\nfunction printValue(value, quoteStrings) {\n    let result = printSimpleValue(value, quoteStrings);\n    if (result !== null) return result;\n    return JSON.stringify(value, function(key, value) {\n        let result = printSimpleValue(this[key], quoteStrings);\n        if (result !== null) return result;\n        return value;\n    }, 2);\n}\nfunction toArray(value) {\n    return value == null ? [] : [].concat(value);\n}\nlet _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;\nlet strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\n_Symbol$toStringTag = Symbol.toStringTag;\nclass ValidationErrorNoStack {\n    constructor(errorOrErrors, value, field, type){\n        this.name = void 0;\n        this.message = void 0;\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = void 0;\n        this.inner = void 0;\n        this[_Symbol$toStringTag] = \"Error\";\n        this.name = \"ValidationError\";\n        this.value = value;\n        this.path = field;\n        this.type = type;\n        this.errors = [];\n        this.inner = [];\n        toArray(errorOrErrors).forEach((err)=>{\n            if (ValidationError.isError(err)) {\n                this.errors.push(...err.errors);\n                const innerErrors = err.inner.length ? err.inner : [\n                    err\n                ];\n                this.inner.push(...innerErrors);\n            } else {\n                this.errors.push(err);\n            }\n        });\n        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];\n    }\n}\n_Symbol$hasInstance = Symbol.hasInstance;\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass ValidationError extends Error {\n    static formatError(message, params) {\n        // Attempt to make the path more friendly for error message interpolation.\n        const path = params.label || params.path || \"this\";\n        // Store the original path under `originalPath` so it isn't lost to custom\n        // message functions; e.g., ones provided in `setLocale()` calls.\n        params = Object.assign({}, params, {\n            path,\n            originalPath: params.path\n        });\n        if (typeof message === \"string\") return message.replace(strReg, (_, key)=>printValue(params[key]));\n        if (typeof message === \"function\") return message(params);\n        return message;\n    }\n    static isError(err) {\n        return err && err.name === \"ValidationError\";\n    }\n    constructor(errorOrErrors, value, field, type, disableStack){\n        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);\n        if (disableStack) {\n            return errorNoStack;\n        }\n        super();\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = [];\n        this.inner = [];\n        this[_Symbol$toStringTag2] = \"Error\";\n        this.name = errorNoStack.name;\n        this.message = errorNoStack.message;\n        this.type = errorNoStack.type;\n        this.value = errorNoStack.value;\n        this.path = errorNoStack.path;\n        this.errors = errorNoStack.errors;\n        this.inner = errorNoStack.inner;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ValidationError);\n        }\n    }\n    static [_Symbol$hasInstance](inst) {\n        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);\n    }\n}\nlet mixed = {\n    default: \"${path} is invalid\",\n    required: \"${path} is a required field\",\n    defined: \"${path} must be defined\",\n    notNull: \"${path} cannot be null\",\n    oneOf: \"${path} must be one of the following values: ${values}\",\n    notOneOf: \"${path} must not be one of the following values: ${values}\",\n    notType: ({ path, type, value, originalValue })=>{\n        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : \".\";\n        return type !== \"mixed\" ? `${path} must be a \\`${type}\\` type, ` + `but the final value was: \\`${printValue(value, true)}\\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \\`${printValue(value, true)}\\`` + castMsg;\n    }\n};\nlet string = {\n    length: \"${path} must be exactly ${length} characters\",\n    min: \"${path} must be at least ${min} characters\",\n    max: \"${path} must be at most ${max} characters\",\n    matches: '${path} must match the following: \"${regex}\"',\n    email: \"${path} must be a valid email\",\n    url: \"${path} must be a valid URL\",\n    uuid: \"${path} must be a valid UUID\",\n    datetime: \"${path} must be a valid ISO date-time\",\n    datetime_precision: \"${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits\",\n    datetime_offset: '${path} must be a valid ISO date-time with UTC \"Z\" timezone',\n    trim: \"${path} must be a trimmed string\",\n    lowercase: \"${path} must be a lowercase string\",\n    uppercase: \"${path} must be a upper case string\"\n};\nlet number = {\n    min: \"${path} must be greater than or equal to ${min}\",\n    max: \"${path} must be less than or equal to ${max}\",\n    lessThan: \"${path} must be less than ${less}\",\n    moreThan: \"${path} must be greater than ${more}\",\n    positive: \"${path} must be a positive number\",\n    negative: \"${path} must be a negative number\",\n    integer: \"${path} must be an integer\"\n};\nlet date = {\n    min: \"${path} field must be later than ${min}\",\n    max: \"${path} field must be at earlier than ${max}\"\n};\nlet boolean = {\n    isValue: \"${path} field must be ${value}\"\n};\nlet object = {\n    noUnknown: \"${path} field has unspecified keys: ${unknown}\",\n    exact: \"${path} object contains unknown properties: ${properties}\"\n};\nlet array = {\n    min: \"${path} field must have at least ${min} items\",\n    max: \"${path} field must have less than or equal to ${max} items\",\n    length: \"${path} must have ${length} items\"\n};\nlet tuple = {\n    notType: (params)=>{\n        const { path, value, spec } = params;\n        const typeLen = spec.types.length;\n        if (Array.isArray(value)) {\n            if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n            if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n        }\n        return ValidationError.formatError(mixed.notType, params);\n    }\n};\nvar locale = Object.assign(Object.create(null), {\n    mixed,\n    string,\n    number,\n    date,\n    object,\n    array,\n    boolean,\n    tuple\n});\nconst isSchema = (obj)=>obj && obj.__isYupSchema__;\nclass Condition {\n    static fromOptions(refs, config) {\n        if (!config.then && !config.otherwise) throw new TypeError(\"either `then:` or `otherwise:` is required for `when()` conditions\");\n        let { is, then, otherwise } = config;\n        let check = typeof is === \"function\" ? is : (...values)=>values.every((value)=>value === is);\n        return new Condition(refs, (values, schema)=>{\n            var _branch;\n            let branch = check(...values) ? then : otherwise;\n            return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n        });\n    }\n    constructor(refs, builder){\n        this.fn = void 0;\n        this.refs = refs;\n        this.refs = refs;\n        this.fn = builder;\n    }\n    resolve(base, options) {\n        let values = this.refs.map((ref)=>// TODO: ? operator here?\n            ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n        let schema = this.fn(values, base, options);\n        if (schema === undefined || // @ts-ignore this can be base\n        schema === base) {\n            return base;\n        }\n        if (!isSchema(schema)) throw new TypeError(\"conditions must return a schema object\");\n        return schema.resolve(options);\n    }\n}\nconst prefixes = {\n    context: \"$\",\n    value: \".\"\n};\nfunction create$9(key, options) {\n    return new Reference(key, options);\n}\nclass Reference {\n    constructor(key, options = {}){\n        this.key = void 0;\n        this.isContext = void 0;\n        this.isValue = void 0;\n        this.isSibling = void 0;\n        this.path = void 0;\n        this.getter = void 0;\n        this.map = void 0;\n        if (typeof key !== \"string\") throw new TypeError(\"ref must be a string, got: \" + key);\n        this.key = key.trim();\n        if (key === \"\") throw new TypeError(\"ref must be a non-empty string\");\n        this.isContext = this.key[0] === prefixes.context;\n        this.isValue = this.key[0] === prefixes.value;\n        this.isSibling = !this.isContext && !this.isValue;\n        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : \"\";\n        this.path = this.key.slice(prefix.length);\n        this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n        this.map = options.map;\n    }\n    getValue(value, parent, context) {\n        let result = this.isContext ? context : this.isValue ? value : parent;\n        if (this.getter) result = this.getter(result || {});\n        if (this.map) result = this.map(result);\n        return result;\n    }\n    /**\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @param {Object=} options.context\n   * @param {Object=} options.parent\n   */ cast(value, options) {\n        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n    }\n    resolve() {\n        return this;\n    }\n    describe() {\n        return {\n            type: \"ref\",\n            key: this.key\n        };\n    }\n    toString() {\n        return `Ref(${this.key})`;\n    }\n    static isRef(value) {\n        return value && value.__isYupRef;\n    }\n}\n// @ts-ignore\nReference.prototype.__isYupRef = true;\nconst isAbsent = (value)=>value == null;\nfunction createValidation(config) {\n    function validate({ value, path = \"\", options, originalValue, schema }, panic, next) {\n        const { name, test, params, message, skipAbsent } = config;\n        let { parent, context, abortEarly = schema.spec.abortEarly, disableStackTrace = schema.spec.disableStackTrace } = options;\n        const resolveOptions = {\n            value,\n            parent,\n            context\n        };\n        function createError(overrides = {}) {\n            const nextParams = resolveParams(Object.assign({\n                value,\n                originalValue,\n                label: schema.spec.label,\n                path: overrides.path || path,\n                spec: schema.spec,\n                disableStackTrace: overrides.disableStackTrace || disableStackTrace\n            }, params, overrides.params), resolveOptions);\n            const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);\n            error.params = nextParams;\n            return error;\n        }\n        const invalid = abortEarly ? panic : next;\n        let ctx = {\n            path,\n            parent,\n            type: name,\n            from: options.from,\n            createError,\n            resolve (item) {\n                return resolveMaybeRef(item, resolveOptions);\n            },\n            options,\n            originalValue,\n            schema\n        };\n        const handleResult = (validOrError)=>{\n            if (ValidationError.isError(validOrError)) invalid(validOrError);\n            else if (!validOrError) invalid(createError());\n            else next(null);\n        };\n        const handleError = (err)=>{\n            if (ValidationError.isError(err)) invalid(err);\n            else panic(err);\n        };\n        const shouldSkip = skipAbsent && isAbsent(value);\n        if (shouldSkip) {\n            return handleResult(true);\n        }\n        let result;\n        try {\n            var _result;\n            result = test.call(ctx, value, ctx);\n            if (typeof ((_result = result) == null ? void 0 : _result.then) === \"function\") {\n                if (options.sync) {\n                    throw new Error(`Validation test of type: \"${ctx.type}\" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);\n                }\n                return Promise.resolve(result).then(handleResult, handleError);\n            }\n        } catch (err) {\n            handleError(err);\n            return;\n        }\n        handleResult(result);\n    }\n    validate.OPTIONS = config;\n    return validate;\n}\n// Warning: mutates the input\nfunction resolveParams(params, options) {\n    if (!params) return params;\n    for (const key of Object.keys(params)){\n        params[key] = resolveMaybeRef(params[key], options);\n    }\n    return params;\n}\nfunction resolveMaybeRef(item, options) {\n    return Reference.isRef(item) ? item.getValue(options.value, options.parent, options.context) : item;\n}\nfunction getIn(schema, path, value, context = value) {\n    let parent, lastPart, lastPartDebug;\n    // root path: ''\n    if (!path) return {\n        parent,\n        parentPath: path,\n        schema\n    };\n    (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray)=>{\n        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n        schema = schema.resolve({\n            context,\n            parent,\n            value\n        });\n        let isTuple = schema.type === \"tuple\";\n        let idx = isArray ? parseInt(part, 10) : 0;\n        if (schema.innerType || isTuple) {\n            if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part \"${lastPartDebug}\" must contain an index to the tuple element, e.g. \"${lastPartDebug}[0]\"`);\n            if (value && idx >= value.length) {\n                throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n            }\n            parent = value;\n            value = value && value[idx];\n            schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n        }\n        // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n        // in these cases the current part is the next schema and should be processed\n        // in this iteration. For cases where the index signature is included this\n        // check will fail and we'll handle the `child` part on the next iteration like normal\n        if (!isArray) {\n            if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema.type}\")`);\n            parent = value;\n            value = value && value[part];\n            schema = schema.fields[part];\n        }\n        lastPart = part;\n        lastPartDebug = isBracket ? \"[\" + _part + \"]\" : \".\" + _part;\n    });\n    return {\n        schema,\n        parent,\n        parentPath: lastPart\n    };\n}\nfunction reach(obj, path, value, context) {\n    return getIn(obj, path, value, context).schema;\n}\nclass ReferenceSet extends Set {\n    describe() {\n        const description = [];\n        for (const item of this.values()){\n            description.push(Reference.isRef(item) ? item.describe() : item);\n        }\n        return description;\n    }\n    resolveAll(resolve) {\n        let result = [];\n        for (const item of this.values()){\n            result.push(resolve(item));\n        }\n        return result;\n    }\n    clone() {\n        return new ReferenceSet(this.values());\n    }\n    merge(newItems, removeItems) {\n        const next = this.clone();\n        newItems.forEach((value)=>next.add(value));\n        removeItems.forEach((value)=>next.delete(value));\n        return next;\n    }\n}\n// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction clone(src, seen = new Map()) {\n    if (isSchema(src) || !src || typeof src !== \"object\") return src;\n    if (seen.has(src)) return seen.get(src);\n    let copy;\n    if (src instanceof Date) {\n        // Date\n        copy = new Date(src.getTime());\n        seen.set(src, copy);\n    } else if (src instanceof RegExp) {\n        // RegExp\n        copy = new RegExp(src);\n        seen.set(src, copy);\n    } else if (Array.isArray(src)) {\n        // Array\n        copy = new Array(src.length);\n        seen.set(src, copy);\n        for(let i = 0; i < src.length; i++)copy[i] = clone(src[i], seen);\n    } else if (src instanceof Map) {\n        // Map\n        copy = new Map();\n        seen.set(src, copy);\n        for (const [k, v] of src.entries())copy.set(k, clone(v, seen));\n    } else if (src instanceof Set) {\n        // Set\n        copy = new Set();\n        seen.set(src, copy);\n        for (const v of src)copy.add(clone(v, seen));\n    } else if (src instanceof Object) {\n        // Object\n        copy = {};\n        seen.set(src, copy);\n        for (const [k, v] of Object.entries(src))copy[k] = clone(v, seen);\n    } else {\n        throw Error(`Unable to clone ${src}`);\n    }\n    return copy;\n}\n/**\n * Copied from @standard-schema/spec to avoid having a dependency on it.\n * https://github.com/standard-schema/standard-schema/blob/main/packages/spec/src/index.ts\n */ function createStandardPath(path) {\n    if (!(path != null && path.length)) {\n        return undefined;\n    }\n    // Array to store the final path segments\n    const segments = [];\n    // Buffer for building the current segment\n    let currentSegment = \"\";\n    // Track if we're inside square brackets (array/property access)\n    let inBrackets = false;\n    // Track if we're inside quotes (for property names with special chars)\n    let inQuotes = false;\n    for(let i = 0; i < path.length; i++){\n        const char = path[i];\n        if (char === \"[\" && !inQuotes) {\n            // When entering brackets, push any accumulated segment after splitting on dots\n            if (currentSegment) {\n                segments.push(...currentSegment.split(\".\").filter(Boolean));\n                currentSegment = \"\";\n            }\n            inBrackets = true;\n            continue;\n        }\n        if (char === \"]\" && !inQuotes) {\n            if (currentSegment) {\n                // Handle numeric indices (e.g. arr[0])\n                if (/^\\d+$/.test(currentSegment)) {\n                    segments.push(currentSegment);\n                } else {\n                    // Handle quoted property names (e.g. obj[\"foo.bar\"])\n                    segments.push(currentSegment.replace(/^\"|\"$/g, \"\"));\n                }\n                currentSegment = \"\";\n            }\n            inBrackets = false;\n            continue;\n        }\n        if (char === '\"') {\n            // Toggle quote state for handling quoted property names\n            inQuotes = !inQuotes;\n            continue;\n        }\n        if (char === \".\" && !inBrackets && !inQuotes) {\n            // On dots outside brackets/quotes, push current segment\n            if (currentSegment) {\n                segments.push(currentSegment);\n                currentSegment = \"\";\n            }\n            continue;\n        }\n        currentSegment += char;\n    }\n    // Push any remaining segment after splitting on dots\n    if (currentSegment) {\n        segments.push(...currentSegment.split(\".\").filter(Boolean));\n    }\n    return segments;\n}\nfunction createStandardIssues(error, parentPath) {\n    const path = parentPath ? `${parentPath}.${error.path}` : error.path;\n    return error.errors.map((err)=>({\n            message: err,\n            path: createStandardPath(path)\n        }));\n}\nfunction issuesFromValidationError(error, parentPath) {\n    var _error$inner;\n    if (!((_error$inner = error.inner) != null && _error$inner.length) && error.errors.length) {\n        return createStandardIssues(error, parentPath);\n    }\n    const path = parentPath ? `${parentPath}.${error.path}` : error.path;\n    return error.inner.flatMap((err)=>issuesFromValidationError(err, path));\n}\n// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a\n// loose Record definition allowing free form usage.\nclass Schema {\n    constructor(options){\n        this.type = void 0;\n        this.deps = [];\n        this.tests = void 0;\n        this.transforms = void 0;\n        this.conditions = [];\n        this._mutate = void 0;\n        this.internalTests = {};\n        this._whitelist = new ReferenceSet();\n        this._blacklist = new ReferenceSet();\n        this.exclusiveTests = Object.create(null);\n        this._typeCheck = void 0;\n        this.spec = void 0;\n        this.tests = [];\n        this.transforms = [];\n        this.withMutation(()=>{\n            this.typeError(mixed.notType);\n        });\n        this.type = options.type;\n        this._typeCheck = options.check;\n        this.spec = Object.assign({\n            strip: false,\n            strict: false,\n            abortEarly: true,\n            recursive: true,\n            disableStackTrace: false,\n            nullable: false,\n            optional: true,\n            coerce: true\n        }, options == null ? void 0 : options.spec);\n        this.withMutation((s)=>{\n            s.nonNullable();\n        });\n    }\n    // TODO: remove\n    get _type() {\n        return this.type;\n    }\n    clone(spec) {\n        if (this._mutate) {\n            if (spec) Object.assign(this.spec, spec);\n            return this;\n        }\n        // if the nested value is a schema we can skip cloning, since\n        // they are already immutable\n        const next = Object.create(Object.getPrototypeOf(this));\n        // @ts-expect-error this is readonly\n        next.type = this.type;\n        next._typeCheck = this._typeCheck;\n        next._whitelist = this._whitelist.clone();\n        next._blacklist = this._blacklist.clone();\n        next.internalTests = Object.assign({}, this.internalTests);\n        next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n        // @ts-expect-error this is readonly\n        next.deps = [\n            ...this.deps\n        ];\n        next.conditions = [\n            ...this.conditions\n        ];\n        next.tests = [\n            ...this.tests\n        ];\n        next.transforms = [\n            ...this.transforms\n        ];\n        next.spec = clone(Object.assign({}, this.spec, spec));\n        return next;\n    }\n    label(label) {\n        let next = this.clone();\n        next.spec.label = label;\n        return next;\n    }\n    meta(...args) {\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n    withMutation(fn) {\n        let before = this._mutate;\n        this._mutate = true;\n        let result = fn(this);\n        this._mutate = before;\n        return result;\n    }\n    concat(schema) {\n        if (!schema || schema === this) return this;\n        if (schema.type !== this.type && this.type !== \"mixed\") throw new TypeError(`You cannot \\`concat()\\` schema's of different types: ${this.type} and ${schema.type}`);\n        let base = this;\n        let combined = schema.clone();\n        const mergedSpec = Object.assign({}, base.spec, combined.spec);\n        combined.spec = mergedSpec;\n        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n        // manually merge the blacklist/whitelist (the other `schema` takes\n        // precedence in case of conflicts)\n        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n        // start with the current tests\n        combined.tests = base.tests;\n        combined.exclusiveTests = base.exclusiveTests;\n        // manually add the new tests to ensure\n        // the deduping logic is consistent\n        combined.withMutation((next)=>{\n            schema.tests.forEach((fn)=>{\n                next.test(fn.OPTIONS);\n            });\n        });\n        combined.transforms = [\n            ...base.transforms,\n            ...combined.transforms\n        ];\n        return combined;\n    }\n    isType(v) {\n        if (v == null) {\n            if (this.spec.nullable && v === null) return true;\n            if (this.spec.optional && v === undefined) return true;\n            return false;\n        }\n        return this._typeCheck(v);\n    }\n    resolve(options) {\n        let schema = this;\n        if (schema.conditions.length) {\n            let conditions = schema.conditions;\n            schema = schema.clone();\n            schema.conditions = [];\n            schema = conditions.reduce((prevSchema, condition)=>condition.resolve(prevSchema, options), schema);\n            schema = schema.resolve(options);\n        }\n        return schema;\n    }\n    resolveOptions(options) {\n        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;\n        return Object.assign({}, options, {\n            from: options.from || [],\n            strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n            abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n            recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,\n            disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace\n        });\n    }\n    /**\n   * Run the configured transform pipeline over an input value.\n   */ cast(value, options = {}) {\n        let resolvedSchema = this.resolve(Object.assign({\n            value\n        }, options));\n        let allowOptionality = options.assert === \"ignore-optionality\";\n        let result = resolvedSchema._cast(value, options);\n        if (options.assert !== false && !resolvedSchema.isType(result)) {\n            if (allowOptionality && isAbsent(result)) {\n                return result;\n            }\n            let formattedValue = printValue(value);\n            let formattedResult = printValue(result);\n            throw new TypeError(`The value of ${options.path || \"field\"} could not be cast to a value ` + `that satisfies the schema type: \"${resolvedSchema.type}\". \\n\\n` + `attempted value: ${formattedValue} \\n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : \"\"));\n        }\n        return result;\n    }\n    _cast(rawValue, options) {\n        let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn)=>fn.call(this, prevValue, rawValue, this), rawValue);\n        if (value === undefined) {\n            value = this.getDefault(options);\n        }\n        return value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let { path, originalValue = _value, strict = this.spec.strict } = options;\n        let value = _value;\n        if (!strict) {\n            value = this._cast(value, Object.assign({\n                assert: false\n            }, options));\n        }\n        let initialTests = [];\n        for (let test of Object.values(this.internalTests)){\n            if (test) initialTests.push(test);\n        }\n        this.runTests({\n            path,\n            value,\n            originalValue,\n            options,\n            tests: initialTests\n        }, panic, (initialErrors)=>{\n            // even if we aren't ending early we can't proceed further if the types aren't correct\n            if (initialErrors.length) {\n                return next(initialErrors, value);\n            }\n            this.runTests({\n                path,\n                value,\n                originalValue,\n                options,\n                tests: this.tests\n            }, panic, next);\n        });\n    }\n    /**\n   * Executes a set of validations, either schema, produced Tests or a nested\n   * schema validate result.\n   */ runTests(runOptions, panic, next) {\n        let fired = false;\n        let { tests, value, originalValue, path, options } = runOptions;\n        let panicOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            panic(arg, value);\n        };\n        let nextOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            next(arg, value);\n        };\n        let count = tests.length;\n        let nestedErrors = [];\n        if (!count) return nextOnce([]);\n        let args = {\n            value,\n            originalValue,\n            path,\n            options,\n            schema: this\n        };\n        for(let i = 0; i < tests.length; i++){\n            const test = tests[i];\n            test(args, panicOnce, function finishTestRun(err) {\n                if (err) {\n                    Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);\n                }\n                if (--count <= 0) {\n                    nextOnce(nestedErrors);\n                }\n            });\n        }\n    }\n    asNestedTest({ key, index, parent, parentPath, originalParent, options }) {\n        const k = key != null ? key : index;\n        if (k == null) {\n            throw TypeError(\"Must include `key` or `index` for nested validations\");\n        }\n        const isIndex = typeof k === \"number\";\n        let value = parent[k];\n        const testOptions = Object.assign({}, options, {\n            // Nested validations fields are always strict:\n            //    1. parent isn't strict so the casting will also have cast inner values\n            //    2. parent is strict in which case the nested values weren't cast either\n            strict: true,\n            parent,\n            value,\n            originalValue: originalParent[k],\n            // FIXME: tests depend on `index` being passed around deeply,\n            //   we should not let the options.key/index bleed through\n            key: undefined,\n            // index: undefined,\n            [isIndex ? \"index\" : \"key\"]: k,\n            path: isIndex || k.includes(\".\") ? `${parentPath || \"\"}[${isIndex ? k : `\"${k}\"`}]` : (parentPath ? `${parentPath}.` : \"\") + key\n        });\n        return (_, panic, next)=>this.resolve(testOptions)._validate(value, testOptions, panic, next);\n    }\n    validate(value, options) {\n        var _options$disableStack2;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;\n        return new Promise((resolve, reject)=>schema._validate(value, options, (error, parsed)=>{\n                if (ValidationError.isError(error)) error.value = parsed;\n                reject(error);\n            }, (errors, validated)=>{\n                if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));\n                else resolve(validated);\n            }));\n    }\n    validateSync(value, options) {\n        var _options$disableStack3;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let result;\n        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;\n        schema._validate(value, Object.assign({}, options, {\n            sync: true\n        }), (error, parsed)=>{\n            if (ValidationError.isError(error)) error.value = parsed;\n            throw error;\n        }, (errors, validated)=>{\n            if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);\n            result = validated;\n        });\n        return result;\n    }\n    isValid(value, options) {\n        return this.validate(value, options).then(()=>true, (err)=>{\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        });\n    }\n    isValidSync(value, options) {\n        try {\n            this.validateSync(value, options);\n            return true;\n        } catch (err) {\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        }\n    }\n    _getDefault(options) {\n        let defaultValue = this.spec.default;\n        if (defaultValue == null) {\n            return defaultValue;\n        }\n        return typeof defaultValue === \"function\" ? defaultValue.call(this, options) : clone(defaultValue);\n    }\n    getDefault(options) {\n        let schema = this.resolve(options || {});\n        return schema._getDefault(options);\n    }\n    default(def) {\n        if (arguments.length === 0) {\n            return this._getDefault();\n        }\n        let next = this.clone({\n            default: def\n        });\n        return next;\n    }\n    strict(isStrict = true) {\n        return this.clone({\n            strict: isStrict\n        });\n    }\n    nullability(nullable, message) {\n        const next = this.clone({\n            nullable\n        });\n        next.internalTests.nullable = createValidation({\n            message,\n            name: \"nullable\",\n            test (value) {\n                return value === null ? this.schema.spec.nullable : true;\n            }\n        });\n        return next;\n    }\n    optionality(optional, message) {\n        const next = this.clone({\n            optional\n        });\n        next.internalTests.optionality = createValidation({\n            message,\n            name: \"optionality\",\n            test (value) {\n                return value === undefined ? this.schema.spec.optional : true;\n            }\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    defined(message = mixed.defined) {\n        return this.optionality(false, message);\n    }\n    nullable() {\n        return this.nullability(true);\n    }\n    nonNullable(message = mixed.notNull) {\n        return this.nullability(false, message);\n    }\n    required(message = mixed.required) {\n        return this.clone().withMutation((next)=>next.nonNullable(message).defined(message));\n    }\n    notRequired() {\n        return this.clone().withMutation((next)=>next.nullable().optional());\n    }\n    transform(fn) {\n        let next = this.clone();\n        next.transforms.push(fn);\n        return next;\n    }\n    /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */ test(...args) {\n        let opts;\n        if (args.length === 1) {\n            if (typeof args[0] === \"function\") {\n                opts = {\n                    test: args[0]\n                };\n            } else {\n                opts = args[0];\n            }\n        } else if (args.length === 2) {\n            opts = {\n                name: args[0],\n                test: args[1]\n            };\n        } else {\n            opts = {\n                name: args[0],\n                message: args[1],\n                test: args[2]\n            };\n        }\n        if (opts.message === undefined) opts.message = mixed.default;\n        if (typeof opts.test !== \"function\") throw new TypeError(\"`test` is a required parameters\");\n        let next = this.clone();\n        let validate = createValidation(opts);\n        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n        if (opts.exclusive) {\n            if (!opts.name) throw new TypeError(\"Exclusive tests must provide a unique `name` identifying the test\");\n        }\n        if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n        next.tests = next.tests.filter((fn)=>{\n            if (fn.OPTIONS.name === opts.name) {\n                if (isExclusive) return false;\n                if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n            }\n            return true;\n        });\n        next.tests.push(validate);\n        return next;\n    }\n    when(keys, options) {\n        if (!Array.isArray(keys) && typeof keys !== \"string\") {\n            options = keys;\n            keys = \".\";\n        }\n        let next = this.clone();\n        let deps = toArray(keys).map((key)=>new Reference(key));\n        deps.forEach((dep)=>{\n            // @ts-ignore readonly array\n            if (dep.isSibling) next.deps.push(dep.key);\n        });\n        next.conditions.push(typeof options === \"function\" ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n        return next;\n    }\n    typeError(message) {\n        let next = this.clone();\n        next.internalTests.typeError = createValidation({\n            message,\n            name: \"typeError\",\n            skipAbsent: true,\n            test (value) {\n                if (!this.schema._typeCheck(value)) return this.createError({\n                    params: {\n                        type: this.schema.type\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    oneOf(enums, message = mixed.oneOf) {\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._whitelist.add(val);\n            next._blacklist.delete(val);\n        });\n        next.internalTests.whiteList = createValidation({\n            message,\n            name: \"oneOf\",\n            skipAbsent: true,\n            test (value) {\n                let valids = this.schema._whitelist;\n                let resolved = valids.resolveAll(this.resolve);\n                return resolved.includes(value) ? true : this.createError({\n                    params: {\n                        values: Array.from(valids).join(\", \"),\n                        resolved\n                    }\n                });\n            }\n        });\n        return next;\n    }\n    notOneOf(enums, message = mixed.notOneOf) {\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._blacklist.add(val);\n            next._whitelist.delete(val);\n        });\n        next.internalTests.blacklist = createValidation({\n            message,\n            name: \"notOneOf\",\n            test (value) {\n                let invalids = this.schema._blacklist;\n                let resolved = invalids.resolveAll(this.resolve);\n                if (resolved.includes(value)) return this.createError({\n                    params: {\n                        values: Array.from(invalids).join(\", \"),\n                        resolved\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    strip(strip = true) {\n        let next = this.clone();\n        next.spec.strip = strip;\n        return next;\n    }\n    /**\n   * Return a serialized description of the schema including validations, flags, types etc.\n   *\n   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\n   */ describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const { label, meta, optional, nullable } = next.spec;\n        const description = {\n            meta,\n            label,\n            optional,\n            nullable,\n            default: next.getDefault(options),\n            type: next.type,\n            oneOf: next._whitelist.describe(),\n            notOneOf: next._blacklist.describe(),\n            tests: next.tests.filter((n, idx, list)=>list.findIndex((c)=>c.OPTIONS.name === n.OPTIONS.name) === idx).map((fn)=>{\n                const params = fn.OPTIONS.params && options ? resolveParams(Object.assign({}, fn.OPTIONS.params), options) : fn.OPTIONS.params;\n                return {\n                    name: fn.OPTIONS.name,\n                    params\n                };\n            })\n        };\n        return description;\n    }\n    get [\"~standard\"]() {\n        const schema = this;\n        const standard = {\n            version: 1,\n            vendor: \"yup\",\n            async validate (value) {\n                try {\n                    const result = await schema.validate(value, {\n                        abortEarly: false\n                    });\n                    return {\n                        value: result\n                    };\n                } catch (err) {\n                    if (err instanceof ValidationError) {\n                        return {\n                            issues: issuesFromValidationError(err)\n                        };\n                    }\n                    throw err;\n                }\n            }\n        };\n        return standard;\n    }\n}\n// @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nfor (const method of [\n    \"validate\",\n    \"validateSync\"\n])Schema.prototype[`${method}At`] = function(path, value, options = {}) {\n    const { parent, parentPath, schema } = getIn(this, path, value, options.context);\n    return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n        parent,\n        path\n    }));\n};\nfor (const alias of [\n    \"equals\",\n    \"is\"\n])Schema.prototype[alias] = Schema.prototype.oneOf;\nfor (const alias of [\n    \"not\",\n    \"nope\"\n])Schema.prototype[alias] = Schema.prototype.notOneOf;\nconst returnsTrue = ()=>true;\nfunction create$8(spec) {\n    return new MixedSchema(spec);\n}\nclass MixedSchema extends Schema {\n    constructor(spec){\n        super(typeof spec === \"function\" ? {\n            type: \"mixed\",\n            check: spec\n        } : Object.assign({\n            type: \"mixed\",\n            check: returnsTrue\n        }, spec));\n    }\n}\ncreate$8.prototype = MixedSchema.prototype;\nfunction create$7() {\n    return new BooleanSchema();\n}\nclass BooleanSchema extends Schema {\n    constructor(){\n        super({\n            type: \"boolean\",\n            check (v) {\n                if (v instanceof Boolean) v = v.valueOf();\n                return typeof v === \"boolean\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (ctx.spec.coerce && !ctx.isType(value)) {\n                    if (/^(true|1)$/i.test(String(value))) return true;\n                    if (/^(false|0)$/i.test(String(value))) return false;\n                }\n                return value;\n            });\n        });\n    }\n    isTrue(message = boolean.isValue) {\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"true\"\n            },\n            test (value) {\n                return isAbsent(value) || value === true;\n            }\n        });\n    }\n    isFalse(message = boolean.isValue) {\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"false\"\n            },\n            test (value) {\n                return isAbsent(value) || value === false;\n            }\n        });\n    }\n    default(def) {\n        return super.default(def);\n    }\n    defined(msg) {\n        return super.defined(msg);\n    }\n    optional() {\n        return super.optional();\n    }\n    required(msg) {\n        return super.required(msg);\n    }\n    notRequired() {\n        return super.notRequired();\n    }\n    nullable() {\n        return super.nullable();\n    }\n    nonNullable(msg) {\n        return super.nonNullable(msg);\n    }\n    strip(v) {\n        return super.strip(v);\n    }\n}\ncreate$7.prototype = BooleanSchema.prototype;\n/**\n * This file is a modified version of the file from the following repository:\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * NON-CONFORMANT EDITION.\n *  2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */ // prettier-ignore\n//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9    10 tzHH    11 tzmm\nconst isoReg = /^(\\d{4}|[+-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,.](\\d{1,}))?)?(?:(Z)|([+-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n    const struct = parseDateStruct(date);\n    if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;\n    // timestamps without timezone identifiers should be considered local time\n    if (struct.z === undefined && struct.plusMinus === undefined) {\n        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();\n    }\n    let totalMinutesOffset = 0;\n    if (struct.z !== \"Z\" && struct.plusMinus !== undefined) {\n        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;\n        if (struct.plusMinus === \"+\") totalMinutesOffset = 0 - totalMinutesOffset;\n    }\n    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);\n}\nfunction parseDateStruct(date) {\n    var _regexResult$7$length, _regexResult$;\n    const regexResult = isoReg.exec(date);\n    if (!regexResult) return null;\n    // use of toNumber() avoids NaN timestamps caused by undefined\n    // values being passed to Date constructor\n    return {\n        year: toNumber(regexResult[1]),\n        month: toNumber(regexResult[2], 1) - 1,\n        day: toNumber(regexResult[3], 1),\n        hour: toNumber(regexResult[4]),\n        minute: toNumber(regexResult[5]),\n        second: toNumber(regexResult[6]),\n        millisecond: regexResult[7] ? // allow arbitrary sub-second precision beyond milliseconds\n        toNumber(regexResult[7].substring(0, 3)) : 0,\n        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,\n        z: regexResult[8] || undefined,\n        plusMinus: regexResult[9] || undefined,\n        hourOffset: toNumber(regexResult[10]),\n        minuteOffset: toNumber(regexResult[11])\n    };\n}\nfunction toNumber(str, defaultValue = 0) {\n    return Number(str) || defaultValue;\n}\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nlet rEmail = // eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nlet rUrl = // eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n// eslint-disable-next-line\nlet rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nlet yearMonthDay = \"^\\\\d{4}-\\\\d{2}-\\\\d{2}\";\nlet hourMinuteSecond = \"\\\\d{2}:\\\\d{2}:\\\\d{2}\";\nlet zOrOffset = \"(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)\";\nlet rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\\\.\\\\d+)?${zOrOffset}$`);\nlet isTrimmed = (value)=>isAbsent(value) || value === value.trim();\nlet objStringTag = ({}).toString();\nfunction create$6() {\n    return new StringSchema();\n}\nclass StringSchema extends Schema {\n    constructor(){\n        super({\n            type: \"string\",\n            check (value) {\n                if (value instanceof String) value = value.valueOf();\n                return typeof value === \"string\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce || ctx.isType(value)) return value;\n                // don't ever convert arrays\n                if (Array.isArray(value)) return value;\n                const strValue = value != null && value.toString ? value.toString() : value;\n                // no one wants plain objects converted to [Object object]\n                if (strValue === objStringTag) return value;\n                return strValue;\n            });\n        });\n    }\n    required(message) {\n        return super.required(message).withMutation((schema)=>schema.test({\n                message: message || mixed.required,\n                name: \"required\",\n                skipAbsent: true,\n                test: (value)=>!!value.length\n            }));\n    }\n    notRequired() {\n        return super.notRequired().withMutation((schema)=>{\n            schema.tests = schema.tests.filter((t)=>t.OPTIONS.name !== \"required\");\n            return schema;\n        });\n    }\n    length(length, message = string.length) {\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message = string.min) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message = string.max) {\n        return this.test({\n            name: \"max\",\n            exclusive: true,\n            message,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    matches(regex, options) {\n        let excludeEmptyString = false;\n        let message;\n        let name;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ excludeEmptyString = false, message, name } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.test({\n            name: name || \"matches\",\n            message: message || string.matches,\n            params: {\n                regex\n            },\n            skipAbsent: true,\n            test: (value)=>value === \"\" && excludeEmptyString || value.search(regex) !== -1\n        });\n    }\n    email(message = string.email) {\n        return this.matches(rEmail, {\n            name: \"email\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    url(message = string.url) {\n        return this.matches(rUrl, {\n            name: \"url\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    uuid(message = string.uuid) {\n        return this.matches(rUUID, {\n            name: \"uuid\",\n            message,\n            excludeEmptyString: false\n        });\n    }\n    datetime(options) {\n        let message = \"\";\n        let allowOffset;\n        let precision;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ message = \"\", allowOffset = false, precision = undefined } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.matches(rIsoDateTime, {\n            name: \"datetime\",\n            message: message || string.datetime,\n            excludeEmptyString: true\n        }).test({\n            name: \"datetime_offset\",\n            message: message || string.datetime_offset,\n            params: {\n                allowOffset\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || allowOffset) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return !!struct.z;\n            }\n        }).test({\n            name: \"datetime_precision\",\n            message: message || string.datetime_precision,\n            params: {\n                precision\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || precision == undefined) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return struct.precision === precision;\n            }\n        });\n    }\n    //-- transforms --\n    ensure() {\n        return this.default(\"\").transform((val)=>val === null ? \"\" : val);\n    }\n    trim(message = string.trim) {\n        return this.transform((val)=>val != null ? val.trim() : val).test({\n            message,\n            name: \"trim\",\n            test: isTrimmed\n        });\n    }\n    lowercase(message = string.lowercase) {\n        return this.transform((value)=>!isAbsent(value) ? value.toLowerCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toLowerCase()\n        });\n    }\n    uppercase(message = string.uppercase) {\n        return this.transform((value)=>!isAbsent(value) ? value.toUpperCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toUpperCase()\n        });\n    }\n}\ncreate$6.prototype = StringSchema.prototype;\n//\n// String Interfaces\n//\nlet isNaN$1 = (value)=>value != +value;\nfunction create$5() {\n    return new NumberSchema();\n}\nclass NumberSchema extends Schema {\n    constructor(){\n        super({\n            type: \"number\",\n            check (value) {\n                if (value instanceof Number) value = value.valueOf();\n                return typeof value === \"number\" && !isNaN$1(value);\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce) return value;\n                let parsed = value;\n                if (typeof parsed === \"string\") {\n                    parsed = parsed.replace(/\\s/g, \"\");\n                    if (parsed === \"\") return NaN;\n                    // don't use parseFloat to avoid positives on alpha-numeric strings\n                    parsed = +parsed;\n                }\n                // null -> NaN isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (ctx.isType(parsed) || parsed === null) return parsed;\n                return parseFloat(parsed);\n            });\n        });\n    }\n    min(min, message = number.min) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message = number.max) {\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(max);\n            }\n        });\n    }\n    lessThan(less, message = number.lessThan) {\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                less\n            },\n            skipAbsent: true,\n            test (value) {\n                return value < this.resolve(less);\n            }\n        });\n    }\n    moreThan(more, message = number.moreThan) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                more\n            },\n            skipAbsent: true,\n            test (value) {\n                return value > this.resolve(more);\n            }\n        });\n    }\n    positive(msg = number.positive) {\n        return this.moreThan(0, msg);\n    }\n    negative(msg = number.negative) {\n        return this.lessThan(0, msg);\n    }\n    integer(message = number.integer) {\n        return this.test({\n            name: \"integer\",\n            message,\n            skipAbsent: true,\n            test: (val)=>Number.isInteger(val)\n        });\n    }\n    truncate() {\n        return this.transform((value)=>!isAbsent(value) ? value | 0 : value);\n    }\n    round(method) {\n        var _method;\n        let avail = [\n            \"ceil\",\n            \"floor\",\n            \"round\",\n            \"trunc\"\n        ];\n        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || \"round\";\n        // this exists for symemtry with the new Math.trunc\n        if (method === \"trunc\") return this.truncate();\n        if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError(\"Only valid options for round() are: \" + avail.join(\", \"));\n        return this.transform((value)=>!isAbsent(value) ? Math[method](value) : value);\n    }\n}\ncreate$5.prototype = NumberSchema.prototype;\n//\n// Number Interfaces\n//\nlet invalidDate = new Date(\"\");\nlet isDate = (obj)=>Object.prototype.toString.call(obj) === \"[object Date]\";\nfunction create$4() {\n    return new DateSchema();\n}\nclass DateSchema extends Schema {\n    constructor(){\n        super({\n            type: \"date\",\n            check (v) {\n                return isDate(v) && !isNaN(v.getTime());\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n                value = parseIsoDate(value);\n                // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n                return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n            });\n        });\n    }\n    prepareParam(ref, name) {\n        let param;\n        if (!Reference.isRef(ref)) {\n            let cast = this.cast(ref);\n            if (!this._typeCheck(cast)) throw new TypeError(`\\`${name}\\` must be a Date or a value that can be \\`cast()\\` to a Date`);\n            param = cast;\n        } else {\n            param = ref;\n        }\n        return param;\n    }\n    min(min, message = date.min) {\n        let limit = this.prepareParam(min, \"min\");\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(limit);\n            }\n        });\n    }\n    max(max, message = date.max) {\n        let limit = this.prepareParam(max, \"max\");\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(limit);\n            }\n        });\n    }\n}\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n// @ts-expect-error\nfunction sortFields(fields, excludedEdges = []) {\n    let edges = [];\n    let nodes = new Set();\n    let excludes = new Set(excludedEdges.map(([a, b])=>`${a}-${b}`));\n    function addNode(depPath, key) {\n        let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n        nodes.add(node);\n        if (!excludes.has(`${key}-${node}`)) edges.push([\n            key,\n            node\n        ]);\n    }\n    for (const key of Object.keys(fields)){\n        let value = fields[key];\n        nodes.add(key);\n        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);\n        else if (isSchema(value) && \"deps\" in value) value.deps.forEach((path)=>addNode(path, key));\n    }\n    return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\nfunction findIndex(arr, err) {\n    let idx = Infinity;\n    arr.some((key, ii)=>{\n        var _err$path;\n        if ((_err$path = err.path) != null && _err$path.includes(key)) {\n            idx = ii;\n            return true;\n        }\n    });\n    return idx;\n}\nfunction sortByKeyOrder(keys) {\n    return (a, b)=>{\n        return findIndex(keys, a) - findIndex(keys, b);\n    };\n}\nconst parseJson = (value, _, ctx)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    let parsed = value;\n    try {\n        parsed = JSON.parse(value);\n    } catch (err) {\n    /* */ }\n    return ctx.isType(parsed) ? parsed : value;\n};\n// @ts-ignore\nfunction deepPartial(schema) {\n    if (\"fields\" in schema) {\n        const partial = {};\n        for (const [key, fieldSchema] of Object.entries(schema.fields)){\n            partial[key] = deepPartial(fieldSchema);\n        }\n        return schema.setFields(partial);\n    }\n    if (schema.type === \"array\") {\n        const nextArray = schema.optional();\n        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);\n        return nextArray;\n    }\n    if (schema.type === \"tuple\") {\n        return schema.optional().clone({\n            types: schema.spec.types.map(deepPartial)\n        });\n    }\n    if (\"optional\" in schema) {\n        return schema.optional();\n    }\n    return schema;\n}\nconst deepHas = (obj, p)=>{\n    const path = [\n        ...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)\n    ];\n    if (path.length === 1) return path[0] in obj;\n    let last = path.pop();\n    let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n    return !!(parent && last in parent);\n};\nlet isObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\";\nfunction unknown(ctx, value) {\n    let known = Object.keys(ctx.fields);\n    return Object.keys(value).filter((key)=>known.indexOf(key) === -1);\n}\nconst defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n    return new ObjectSchema(spec);\n}\nclass ObjectSchema extends Schema {\n    constructor(spec){\n        super({\n            type: \"object\",\n            check (value) {\n                return isObject(value) || typeof value === \"function\";\n            }\n        });\n        this.fields = Object.create(null);\n        this._sortErrors = defaultSort;\n        this._nodes = [];\n        this._excludedEdges = [];\n        this.withMutation(()=>{\n            if (spec) {\n                this.shape(spec);\n            }\n        });\n    }\n    _cast(_value, options = {}) {\n        var _options$stripUnknown;\n        let value = super._cast(_value, options);\n        //should ignore nulls here\n        if (value === undefined) return this.getDefault(options);\n        if (!this._typeCheck(value)) return value;\n        let fields = this.fields;\n        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n        let props = [].concat(this._nodes, Object.keys(value).filter((v)=>!this._nodes.includes(v)));\n        let intermediateValue = {}; // is filled during the transform below\n        let innerOptions = Object.assign({}, options, {\n            parent: intermediateValue,\n            __validating: options.__validating || false\n        });\n        let isChanged = false;\n        for (const prop of props){\n            let field = fields[prop];\n            let exists = prop in value;\n            if (field) {\n                let fieldValue;\n                let inputValue = value[prop];\n                // safe to mutate since this is fired in sequence\n                innerOptions.path = (options.path ? `${options.path}.` : \"\") + prop;\n                field = field.resolve({\n                    value: inputValue,\n                    context: options.context,\n                    parent: intermediateValue\n                });\n                let fieldSpec = field instanceof Schema ? field.spec : undefined;\n                let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n                if (fieldSpec != null && fieldSpec.strip) {\n                    isChanged = isChanged || prop in value;\n                    continue;\n                }\n                fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n                field.cast(value[prop], innerOptions) : value[prop];\n                if (fieldValue !== undefined) {\n                    intermediateValue[prop] = fieldValue;\n                }\n            } else if (exists && !strip) {\n                intermediateValue[prop] = value[prop];\n            }\n            if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n                isChanged = true;\n            }\n        }\n        return isChanged ? intermediateValue : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let { from = [], originalValue = _value, recursive = this.spec.recursive } = options;\n        options.from = [\n            {\n                schema: this,\n                value: originalValue\n            },\n            ...from\n        ];\n        // this flag is needed for handling `strict` correctly in the context of\n        // validation vs just casting. e.g strict() on a field is only used when validating\n        options.__validating = true;\n        options.originalValue = originalValue;\n        super._validate(_value, options, panic, (objectErrors, value)=>{\n            if (!recursive || !isObject(value)) {\n                next(objectErrors, value);\n                return;\n            }\n            originalValue = originalValue || value;\n            let tests = [];\n            for (let key of this._nodes){\n                let field = this.fields[key];\n                if (!field || Reference.isRef(field)) {\n                    continue;\n                }\n                tests.push(field.asNestedTest({\n                    options,\n                    key,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: originalValue\n                }));\n            }\n            this.runTests({\n                tests,\n                value,\n                originalValue,\n                options\n            }, panic, (fieldErrors)=>{\n                next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);\n            });\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        next.fields = Object.assign({}, this.fields);\n        next._nodes = this._nodes;\n        next._excludedEdges = this._excludedEdges;\n        next._sortErrors = this._sortErrors;\n        return next;\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        let nextFields = next.fields;\n        for (let [field, schemaOrRef] of Object.entries(this.fields)){\n            const target = nextFields[field];\n            nextFields[field] = target === undefined ? schemaOrRef : target;\n        }\n        return next.withMutation((s)=>// XXX: excludes here is wrong\n            s.setFields(nextFields, [\n                ...this._excludedEdges,\n                ...schema._excludedEdges\n            ]));\n    }\n    _getDefault(options) {\n        if (\"default\" in this.spec) {\n            return super._getDefault(options);\n        }\n        // if there is no default set invent one\n        if (!this._nodes.length) {\n            return undefined;\n        }\n        let dft = {};\n        this._nodes.forEach((key)=>{\n            var _innerOptions;\n            const field = this.fields[key];\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            dft[key] = field && \"getDefault\" in field ? field.getDefault(innerOptions) : undefined;\n        });\n        return dft;\n    }\n    setFields(shape, excludedEdges) {\n        let next = this.clone();\n        next.fields = shape;\n        next._nodes = sortFields(shape, excludedEdges);\n        next._sortErrors = sortByKeyOrder(Object.keys(shape));\n        // XXX: this carries over edges which may not be what you want\n        if (excludedEdges) next._excludedEdges = excludedEdges;\n        return next;\n    }\n    shape(additions, excludes = []) {\n        return this.clone().withMutation((next)=>{\n            let edges = next._excludedEdges;\n            if (excludes.length) {\n                if (!Array.isArray(excludes[0])) excludes = [\n                    excludes\n                ];\n                edges = [\n                    ...next._excludedEdges,\n                    ...excludes\n                ];\n            }\n            // XXX: excludes here is wrong\n            return next.setFields(Object.assign(next.fields, additions), edges);\n        });\n    }\n    partial() {\n        const partial = {};\n        for (const [key, schema] of Object.entries(this.fields)){\n            partial[key] = \"optional\" in schema && schema.optional instanceof Function ? schema.optional() : schema;\n        }\n        return this.setFields(partial);\n    }\n    deepPartial() {\n        const next = deepPartial(this);\n        return next;\n    }\n    pick(keys) {\n        const picked = {};\n        for (const key of keys){\n            if (this.fields[key]) picked[key] = this.fields[key];\n        }\n        return this.setFields(picked, this._excludedEdges.filter(([a, b])=>keys.includes(a) && keys.includes(b)));\n    }\n    omit(keys) {\n        const remaining = [];\n        for (const key of Object.keys(this.fields)){\n            if (keys.includes(key)) continue;\n            remaining.push(key);\n        }\n        return this.pick(remaining);\n    }\n    from(from, to, alias) {\n        let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            let newObj = obj;\n            if (deepHas(obj, from)) {\n                newObj = Object.assign({}, obj);\n                if (!alias) delete newObj[from];\n                newObj[to] = fromGetter(obj);\n            }\n            return newObj;\n        });\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    /**\n   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys\n   */ exact(message) {\n        return this.test({\n            name: \"exact\",\n            exclusive: true,\n            message: message || object.exact,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return unknownKeys.length === 0 || this.createError({\n                    params: {\n                        properties: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n    }\n    stripUnknown() {\n        return this.clone({\n            noUnknown: true\n        });\n    }\n    noUnknown(noAllow = true, message = object.noUnknown) {\n        if (typeof noAllow !== \"boolean\") {\n            message = noAllow;\n            noAllow = true;\n        }\n        let next = this.test({\n            name: \"noUnknown\",\n            exclusive: true,\n            message: message,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return !noAllow || unknownKeys.length === 0 || this.createError({\n                    params: {\n                        unknown: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n        next.spec.noUnknown = noAllow;\n        return next;\n    }\n    unknown(allow = true, message = object.noUnknown) {\n        return this.noUnknown(!allow, message);\n    }\n    transformKeys(fn) {\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            const result = {};\n            for (const key of Object.keys(obj))result[fn(key)] = obj[key];\n            return result;\n        });\n    }\n    camelCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n    }\n    snakeCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n    }\n    constantCase() {\n        return this.transformKeys((key)=>(0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.fields = {};\n        for (const [key, value] of Object.entries(next.fields)){\n            var _innerOptions2;\n            let innerOptions = options;\n            if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            base.fields[key] = value.describe(innerOptions);\n        }\n        return base;\n    }\n}\ncreate$3.prototype = ObjectSchema.prototype;\nfunction create$2(type) {\n    return new ArraySchema(type);\n}\nclass ArraySchema extends Schema {\n    constructor(type){\n        super({\n            type: \"array\",\n            spec: {\n                types: type\n            },\n            check (v) {\n                return Array.isArray(v);\n            }\n        });\n        // `undefined` specifically means uninitialized, as opposed to \"no subtype\"\n        this.innerType = void 0;\n        this.innerType = type;\n    }\n    _cast(_value, _opts) {\n        const value = super._cast(_value, _opts);\n        // should ignore nulls here\n        if (!this._typeCheck(value) || !this.innerType) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = value.map((v, idx)=>{\n            const castElement = this.innerType.cast(v, Object.assign({}, _opts, {\n                path: `${_opts.path || \"\"}[${idx}]`\n            }));\n            if (castElement !== v) {\n                isChanged = true;\n            }\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        var _options$recursive;\n        // let sync = options.sync;\n        // let path = options.path;\n        let innerType = this.innerType;\n        // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n        options.originalValue != null ? options.originalValue : _value;\n        super._validate(_value, options, panic, (arrayErrors, value)=>{\n            var _options$originalValu2;\n            if (!recursive || !innerType || !this._typeCheck(value)) {\n                next(arrayErrors, value);\n                return;\n            }\n            // #950 Ensure that sparse array empty slots are validated\n            let tests = new Array(value.length);\n            for(let index = 0; index < value.length; index++){\n                var _options$originalValu;\n                tests[index] = innerType.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(arrayErrors), value));\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        return next;\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        if (schema.innerType) // @ts-expect-error readonly\n        next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat and will break\n        next.innerType.concat(schema.innerType) : schema.innerType;\n        return next;\n    }\n    of(schema) {\n        // FIXME: this should return a new instance of array without the default to be\n        let next = this.clone();\n        if (!isSchema(schema)) throw new TypeError(\"`array.of()` sub-schema must be a valid yup schema not: \" + printValue(schema));\n        // @ts-expect-error readonly\n        next.innerType = schema;\n        next.spec = Object.assign({}, next.spec, {\n            types: schema\n        });\n        return next;\n    }\n    length(length, message = array.length) {\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message) {\n        message = message || array.min;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            // FIXME(ts): Array<typeof T>\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message) {\n        message = message || array.max;\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    ensure() {\n        return this.default(()=>[]).transform((val, original)=>{\n            // We don't want to return `null` for nullable schema\n            if (this._typeCheck(val)) return val;\n            return original == null ? [] : [].concat(original);\n        });\n    }\n    compact(rejector) {\n        let reject = !rejector ? (v)=>!!v : (v, i, a)=>!rejector(v, i, a);\n        return this.transform((values)=>values != null ? values.filter(reject) : values);\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        if (next.innerType) {\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[0]\n                });\n            }\n            base.innerType = next.innerType.describe(innerOptions);\n        }\n        return base;\n    }\n}\ncreate$2.prototype = ArraySchema.prototype;\n// @ts-ignore\nfunction create$1(schemas) {\n    return new TupleSchema(schemas);\n}\nclass TupleSchema extends Schema {\n    constructor(schemas){\n        super({\n            type: \"tuple\",\n            spec: {\n                types: schemas\n            },\n            check (v) {\n                const types = this.spec.types;\n                return Array.isArray(v) && v.length === types.length;\n            }\n        });\n        this.withMutation(()=>{\n            this.typeError(tuple.notType);\n        });\n    }\n    _cast(inputValue, options) {\n        const { types } = this.spec;\n        const value = super._cast(inputValue, options);\n        if (!this._typeCheck(value)) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = types.map((type, idx)=>{\n            const castElement = type.cast(value[idx], Object.assign({}, options, {\n                path: `${options.path || \"\"}[${idx}]`\n            }));\n            if (castElement !== value[idx]) isChanged = true;\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let itemTypes = this.spec.types;\n        super._validate(_value, options, panic, (tupleErrors, value)=>{\n            var _options$originalValu2;\n            // intentionally not respecting recursive\n            if (!this._typeCheck(value)) {\n                next(tupleErrors, value);\n                return;\n            }\n            let tests = [];\n            for (let [index, itemSchema] of itemTypes.entries()){\n                var _options$originalValu;\n                tests[index] = itemSchema.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(tupleErrors), value));\n        });\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.innerType = next.spec.types.map((schema, index)=>{\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[index]\n                });\n            }\n            return schema.describe(innerOptions);\n        });\n        return base;\n    }\n}\ncreate$1.prototype = TupleSchema.prototype;\nfunction create(builder) {\n    return new Lazy(builder);\n}\nfunction catchValidationError(fn) {\n    try {\n        return fn();\n    } catch (err) {\n        if (ValidationError.isError(err)) return Promise.reject(err);\n        throw err;\n    }\n}\nclass Lazy {\n    constructor(builder){\n        this.type = \"lazy\";\n        this.__isYupSchema__ = true;\n        this.spec = void 0;\n        this._resolve = (value, options = {})=>{\n            let schema = this.builder(value, options);\n            if (!isSchema(schema)) throw new TypeError(\"lazy() functions must return a valid schema\");\n            if (this.spec.optional) schema = schema.optional();\n            return schema.resolve(options);\n        };\n        this.builder = builder;\n        this.spec = {\n            meta: undefined,\n            optional: false\n        };\n    }\n    clone(spec) {\n        const next = new Lazy(this.builder);\n        next.spec = Object.assign({}, this.spec, spec);\n        return next;\n    }\n    optionality(optional) {\n        const next = this.clone({\n            optional\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    resolve(options) {\n        return this._resolve(options.value, options);\n    }\n    cast(value, options) {\n        return this._resolve(value, options).cast(value, options);\n    }\n    asNestedTest(config) {\n        let { key, index, parent, options } = config;\n        let value = parent[index != null ? index : key];\n        return this._resolve(value, Object.assign({}, options, {\n            value,\n            parent\n        })).asNestedTest(config);\n    }\n    validate(value, options) {\n        return catchValidationError(()=>this._resolve(value, options).validate(value, options));\n    }\n    validateSync(value, options) {\n        return this._resolve(value, options).validateSync(value, options);\n    }\n    validateAt(path, value, options) {\n        return catchValidationError(()=>this._resolve(value, options).validateAt(path, value, options));\n    }\n    validateSyncAt(path, value, options) {\n        return this._resolve(value, options).validateSyncAt(path, value, options);\n    }\n    isValid(value, options) {\n        try {\n            return this._resolve(value, options).isValid(value, options);\n        } catch (err) {\n            if (ValidationError.isError(err)) {\n                return Promise.resolve(false);\n            }\n            throw err;\n        }\n    }\n    isValidSync(value, options) {\n        return this._resolve(value, options).isValidSync(value, options);\n    }\n    describe(options) {\n        return options ? this.resolve(options).describe(options) : {\n            type: \"lazy\",\n            meta: this.spec.meta,\n            label: undefined\n        };\n    }\n    meta(...args) {\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n    get [\"~standard\"]() {\n        const schema = this;\n        const standard = {\n            version: 1,\n            vendor: \"yup\",\n            async validate (value) {\n                try {\n                    const result = await schema.validate(value, {\n                        abortEarly: false\n                    });\n                    return {\n                        value: result\n                    };\n                } catch (err) {\n                    if (ValidationError.isError(err)) {\n                        return {\n                            issues: issuesFromValidationError(err)\n                        };\n                    }\n                    throw err;\n                }\n            }\n        };\n        return standard;\n    }\n}\nfunction setLocale(custom) {\n    Object.keys(custom).forEach((type)=>{\n        // @ts-ignore\n        Object.keys(custom[type]).forEach((method)=>{\n            // @ts-ignore\n            locale[type][method] = custom[type][method];\n        });\n    });\n}\nfunction addMethod(schemaType, name, fn) {\n    if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError(\"You must provide a yup schema constructor function\");\n    if (typeof name !== \"string\") throw new TypeError(\"A Method name must be provided\");\n    if (typeof fn !== \"function\") throw new TypeError(\"Method function must be provided\");\n    schemaType.prototype[name] = fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGVyLCBmb3JFYWNoLCBzcGxpdCwgbm9ybWFsaXplUGF0aCwgam9pbiB9IGZyb20gJ3Byb3BlcnR5LWV4cHInO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBzbmFrZUNhc2UgfSBmcm9tICd0aW55LWNhc2UnO1xuaW1wb3J0IHRvcG9zb3J0IGZyb20gJ3RvcG9zb3J0JztcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgZXJyb3JUb1N0cmluZyA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHN5bWJvbFRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogKCkgPT4gJyc7XG5jb25zdCBTWU1CT0xfUkVHRVhQID0gL15TeW1ib2xcXCgoLiopXFwpKC4qKSQvO1xuZnVuY3Rpb24gcHJpbnROdW1iZXIodmFsKSB7XG4gIGlmICh2YWwgIT0gK3ZhbCkgcmV0dXJuICdOYU4nO1xuICBjb25zdCBpc05lZ2F0aXZlWmVybyA9IHZhbCA9PT0gMCAmJiAxIC8gdmFsIDwgMDtcbiAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvID8gJy0wJyA6ICcnICsgdmFsO1xufVxuZnVuY3Rpb24gcHJpbnRTaW1wbGVWYWx1ZSh2YWwsIHF1b3RlU3RyaW5ncyA9IGZhbHNlKSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSkgcmV0dXJuICcnICsgdmFsO1xuICBjb25zdCB0eXBlT2YgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZU9mID09PSAnbnVtYmVyJykgcmV0dXJuIHByaW50TnVtYmVyKHZhbCk7XG4gIGlmICh0eXBlT2YgPT09ICdzdHJpbmcnKSByZXR1cm4gcXVvdGVTdHJpbmdzID8gYFwiJHt2YWx9XCJgIDogdmFsO1xuICBpZiAodHlwZU9mID09PSAnZnVuY3Rpb24nKSByZXR1cm4gJ1tGdW5jdGlvbiAnICsgKHZhbC5uYW1lIHx8ICdhbm9ueW1vdXMnKSArICddJztcbiAgaWYgKHR5cGVPZiA9PT0gJ3N5bWJvbCcpIHJldHVybiBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbCkucmVwbGFjZShTWU1CT0xfUkVHRVhQLCAnU3ltYm9sKCQxKScpO1xuICBjb25zdCB0YWcgPSB0b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xuICBpZiAodGFnID09PSAnRGF0ZScpIHJldHVybiBpc05hTih2YWwuZ2V0VGltZSgpKSA/ICcnICsgdmFsIDogdmFsLnRvSVNPU3RyaW5nKHZhbCk7XG4gIGlmICh0YWcgPT09ICdFcnJvcicgfHwgdmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiAnWycgKyBlcnJvclRvU3RyaW5nLmNhbGwodmFsKSArICddJztcbiAgaWYgKHRhZyA9PT0gJ1JlZ0V4cCcpIHJldHVybiByZWdFeHBUb1N0cmluZy5jYWxsKHZhbCk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHJpbnRWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKSB7XG4gIGxldCByZXN1bHQgPSBwcmludFNpbXBsZVZhbHVlKHZhbHVlLCBxdW90ZVN0cmluZ3MpO1xuICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHByaW50U2ltcGxlVmFsdWUodGhpc1trZXldLCBxdW90ZVN0cmluZ3MpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LCAyKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KHZhbHVlKTtcbn1cblxubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkaGFzSW5zdGFuY2UsIF9TeW1ib2wkdG9TdHJpbmdUYWcyO1xubGV0IHN0clJlZyA9IC9cXCRcXHtcXHMqKFxcdyspXFxzKlxcfS9nO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmNsYXNzIFZhbGlkYXRpb25FcnJvck5vU3RhY2sge1xuICBjb25zdHJ1Y3RvcihlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpIHtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXNzYWdlID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyID0gdm9pZCAwO1xuICAgIHRoaXNbX1N5bWJvbCR0b1N0cmluZ1RhZ10gPSAnRXJyb3InO1xuICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBmaWVsZDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pbm5lciA9IFtdO1xuICAgIHRvQXJyYXkoZXJyb3JPckVycm9ycykuZm9yRWFjaChlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCguLi5lcnIuZXJyb3JzKTtcbiAgICAgICAgY29uc3QgaW5uZXJFcnJvcnMgPSBlcnIuaW5uZXIubGVuZ3RoID8gZXJyLmlubmVyIDogW2Vycl07XG4gICAgICAgIHRoaXMuaW5uZXIucHVzaCguLi5pbm5lckVycm9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5lcnJvcnMubGVuZ3RoID4gMSA/IGAke3RoaXMuZXJyb3JzLmxlbmd0aH0gZXJyb3JzIG9jY3VycmVkYCA6IHRoaXMuZXJyb3JzWzBdO1xuICB9XG59XG5fU3ltYm9sJGhhc0luc3RhbmNlID0gU3ltYm9sLmhhc0luc3RhbmNlO1xuX1N5bWJvbCR0b1N0cmluZ1RhZzIgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBmb3JtYXRFcnJvcihtZXNzYWdlLCBwYXJhbXMpIHtcbiAgICAvLyBBdHRlbXB0IHRvIG1ha2UgdGhlIHBhdGggbW9yZSBmcmllbmRseSBmb3IgZXJyb3IgbWVzc2FnZSBpbnRlcnBvbGF0aW9uLlxuICAgIGNvbnN0IHBhdGggPSBwYXJhbXMubGFiZWwgfHwgcGFyYW1zLnBhdGggfHwgJ3RoaXMnO1xuICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBwYXRoIHVuZGVyIGBvcmlnaW5hbFBhdGhgIHNvIGl0IGlzbid0IGxvc3QgdG8gY3VzdG9tXG4gICAgLy8gbWVzc2FnZSBmdW5jdGlvbnM7IGUuZy4sIG9uZXMgcHJvdmlkZWQgaW4gYHNldExvY2FsZSgpYCBjYWxscy5cbiAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHtcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFBhdGg6IHBhcmFtcy5wYXRoXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZShzdHJSZWcsIChfLCBrZXkpID0+IHByaW50VmFsdWUocGFyYW1zW2tleV0pKTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBtZXNzYWdlKHBhcmFtcyk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgc3RhdGljIGlzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiBlcnIubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcic7XG4gIH1cbiAgY29uc3RydWN0b3IoZXJyb3JPckVycm9ycywgdmFsdWUsIGZpZWxkLCB0eXBlLCBkaXNhYmxlU3RhY2spIHtcbiAgICBjb25zdCBlcnJvck5vU3RhY2sgPSBuZXcgVmFsaWRhdGlvbkVycm9yTm9TdGFjayhlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpO1xuICAgIGlmIChkaXNhYmxlU3RhY2spIHtcbiAgICAgIHJldHVybiBlcnJvck5vU3RhY2s7XG4gICAgfVxuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMucGFyYW1zID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pbm5lciA9IFtdO1xuICAgIHRoaXNbX1N5bWJvbCR0b1N0cmluZ1RhZzJdID0gJ0Vycm9yJztcbiAgICB0aGlzLm5hbWUgPSBlcnJvck5vU3RhY2submFtZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvck5vU3RhY2subWVzc2FnZTtcbiAgICB0aGlzLnR5cGUgPSBlcnJvck5vU3RhY2sudHlwZTtcbiAgICB0aGlzLnZhbHVlID0gZXJyb3JOb1N0YWNrLnZhbHVlO1xuICAgIHRoaXMucGF0aCA9IGVycm9yTm9TdGFjay5wYXRoO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JOb1N0YWNrLmVycm9ycztcbiAgICB0aGlzLmlubmVyID0gZXJyb3JOb1N0YWNrLmlubmVyO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVmFsaWRhdGlvbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIFtfU3ltYm9sJGhhc0luc3RhbmNlXShpbnN0KSB7XG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvck5vU3RhY2tbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0KSB8fCBzdXBlcltTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3QpO1xuICB9XG59XG5cbmxldCBtaXhlZCA9IHtcbiAgZGVmYXVsdDogJyR7cGF0aH0gaXMgaW52YWxpZCcsXG4gIHJlcXVpcmVkOiAnJHtwYXRofSBpcyBhIHJlcXVpcmVkIGZpZWxkJyxcbiAgZGVmaW5lZDogJyR7cGF0aH0gbXVzdCBiZSBkZWZpbmVkJyxcbiAgbm90TnVsbDogJyR7cGF0aH0gY2Fubm90IGJlIG51bGwnLFxuICBvbmVPZjogJyR7cGF0aH0gbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICR7dmFsdWVzfScsXG4gIG5vdE9uZU9mOiAnJHtwYXRofSBtdXN0IG5vdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICR7dmFsdWVzfScsXG4gIG5vdFR5cGU6ICh7XG4gICAgcGF0aCxcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIG9yaWdpbmFsVmFsdWVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNhc3RNc2cgPSBvcmlnaW5hbFZhbHVlICE9IG51bGwgJiYgb3JpZ2luYWxWYWx1ZSAhPT0gdmFsdWUgPyBgIChjYXN0IGZyb20gdGhlIHZhbHVlIFxcYCR7cHJpbnRWYWx1ZShvcmlnaW5hbFZhbHVlLCB0cnVlKX1cXGApLmAgOiAnLic7XG4gICAgcmV0dXJuIHR5cGUgIT09ICdtaXhlZCcgPyBgJHtwYXRofSBtdXN0IGJlIGEgXFxgJHt0eXBlfVxcYCB0eXBlLCBgICsgYGJ1dCB0aGUgZmluYWwgdmFsdWUgd2FzOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGAgKyBjYXN0TXNnIDogYCR7cGF0aH0gbXVzdCBtYXRjaCB0aGUgY29uZmlndXJlZCB0eXBlLiBgICsgYFRoZSB2YWxpZGF0ZWQgdmFsdWUgd2FzOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGAgKyBjYXN0TXNnO1xuICB9XG59O1xubGV0IHN0cmluZyA9IHtcbiAgbGVuZ3RoOiAnJHtwYXRofSBtdXN0IGJlIGV4YWN0bHkgJHtsZW5ndGh9IGNoYXJhY3RlcnMnLFxuICBtaW46ICcke3BhdGh9IG11c3QgYmUgYXQgbGVhc3QgJHttaW59IGNoYXJhY3RlcnMnLFxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgYXQgbW9zdCAke21heH0gY2hhcmFjdGVycycsXG4gIG1hdGNoZXM6ICcke3BhdGh9IG11c3QgbWF0Y2ggdGhlIGZvbGxvd2luZzogXCIke3JlZ2V4fVwiJyxcbiAgZW1haWw6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBlbWFpbCcsXG4gIHVybDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIFVSTCcsXG4gIHV1aWQ6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBVVUlEJyxcbiAgZGF0ZXRpbWU6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBJU08gZGF0ZS10aW1lJyxcbiAgZGF0ZXRpbWVfcHJlY2lzaW9uOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZSB3aXRoIGEgc3ViLXNlY29uZCBwcmVjaXNpb24gb2YgZXhhY3RseSAke3ByZWNpc2lvbn0gZGlnaXRzJyxcbiAgZGF0ZXRpbWVfb2Zmc2V0OiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZSB3aXRoIFVUQyBcIlpcIiB0aW1lem9uZScsXG4gIHRyaW06ICcke3BhdGh9IG11c3QgYmUgYSB0cmltbWVkIHN0cmluZycsXG4gIGxvd2VyY2FzZTogJyR7cGF0aH0gbXVzdCBiZSBhIGxvd2VyY2FzZSBzdHJpbmcnLFxuICB1cHBlcmNhc2U6ICcke3BhdGh9IG11c3QgYmUgYSB1cHBlciBjYXNlIHN0cmluZydcbn07XG5sZXQgbnVtYmVyID0ge1xuICBtaW46ICcke3BhdGh9IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7bWlufScsXG4gIG1heDogJyR7cGF0aH0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHttYXh9JyxcbiAgbGVzc1RoYW46ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuICR7bGVzc30nLFxuICBtb3JlVGhhbjogJyR7cGF0aH0gbXVzdCBiZSBncmVhdGVyIHRoYW4gJHttb3JlfScsXG4gIHBvc2l0aXZlOiAnJHtwYXRofSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcbiAgbmVnYXRpdmU6ICcke3BhdGh9IG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICBpbnRlZ2VyOiAnJHtwYXRofSBtdXN0IGJlIGFuIGludGVnZXInXG59O1xubGV0IGRhdGUgPSB7XG4gIG1pbjogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSBsYXRlciB0aGFuICR7bWlufScsXG4gIG1heDogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSBhdCBlYXJsaWVyIHRoYW4gJHttYXh9J1xufTtcbmxldCBib29sZWFuID0ge1xuICBpc1ZhbHVlOiAnJHtwYXRofSBmaWVsZCBtdXN0IGJlICR7dmFsdWV9J1xufTtcbmxldCBvYmplY3QgPSB7XG4gIG5vVW5rbm93bjogJyR7cGF0aH0gZmllbGQgaGFzIHVuc3BlY2lmaWVkIGtleXM6ICR7dW5rbm93bn0nLFxuICBleGFjdDogJyR7cGF0aH0gb2JqZWN0IGNvbnRhaW5zIHVua25vd24gcHJvcGVydGllczogJHtwcm9wZXJ0aWVzfSdcbn07XG5sZXQgYXJyYXkgPSB7XG4gIG1pbjogJyR7cGF0aH0gZmllbGQgbXVzdCBoYXZlIGF0IGxlYXN0ICR7bWlufSBpdGVtcycsXG4gIG1heDogJyR7cGF0aH0gZmllbGQgbXVzdCBoYXZlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH0gaXRlbXMnLFxuICBsZW5ndGg6ICcke3BhdGh9IG11c3QgaGF2ZSAke2xlbmd0aH0gaXRlbXMnXG59O1xubGV0IHR1cGxlID0ge1xuICBub3RUeXBlOiBwYXJhbXMgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZSxcbiAgICAgIHNwZWNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGVMZW4gPSBzcGVjLnR5cGVzLmxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCB0eXBlTGVuKSByZXR1cm4gYCR7cGF0aH0gdHVwbGUgdmFsdWUgaGFzIHRvbyBmZXcgaXRlbXMsIGV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7dHlwZUxlbn0gYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gZm9yIHZhbHVlOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGA7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gdHlwZUxlbikgcmV0dXJuIGAke3BhdGh9IHR1cGxlIHZhbHVlIGhhcyB0b28gbWFueSBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvci5mb3JtYXRFcnJvcihtaXhlZC5ub3RUeXBlLCBwYXJhbXMpO1xuICB9XG59O1xudmFyIGxvY2FsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBtaXhlZCxcbiAgc3RyaW5nLFxuICBudW1iZXIsXG4gIGRhdGUsXG4gIG9iamVjdCxcbiAgYXJyYXksXG4gIGJvb2xlYW4sXG4gIHR1cGxlXG59KTtcblxuY29uc3QgaXNTY2hlbWEgPSBvYmogPT4gb2JqICYmIG9iai5fX2lzWXVwU2NoZW1hX187XG5cbmNsYXNzIENvbmRpdGlvbiB7XG4gIHN0YXRpYyBmcm9tT3B0aW9ucyhyZWZzLCBjb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZy50aGVuICYmICFjb25maWcub3RoZXJ3aXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlaXRoZXIgYHRoZW46YCBvciBgb3RoZXJ3aXNlOmAgaXMgcmVxdWlyZWQgZm9yIGB3aGVuKClgIGNvbmRpdGlvbnMnKTtcbiAgICBsZXQge1xuICAgICAgaXMsXG4gICAgICB0aGVuLFxuICAgICAgb3RoZXJ3aXNlXG4gICAgfSA9IGNvbmZpZztcbiAgICBsZXQgY2hlY2sgPSB0eXBlb2YgaXMgPT09ICdmdW5jdGlvbicgPyBpcyA6ICguLi52YWx1ZXMpID0+IHZhbHVlcy5ldmVyeSh2YWx1ZSA9PiB2YWx1ZSA9PT0gaXMpO1xuICAgIHJldHVybiBuZXcgQ29uZGl0aW9uKHJlZnMsICh2YWx1ZXMsIHNjaGVtYSkgPT4ge1xuICAgICAgdmFyIF9icmFuY2g7XG4gICAgICBsZXQgYnJhbmNoID0gY2hlY2soLi4udmFsdWVzKSA/IHRoZW4gOiBvdGhlcndpc2U7XG4gICAgICByZXR1cm4gKF9icmFuY2ggPSBicmFuY2ggPT0gbnVsbCA/IHZvaWQgMCA6IGJyYW5jaChzY2hlbWEpKSAhPSBudWxsID8gX2JyYW5jaCA6IHNjaGVtYTtcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihyZWZzLCBidWlsZGVyKSB7XG4gICAgdGhpcy5mbiA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZnMgPSByZWZzO1xuICAgIHRoaXMucmVmcyA9IHJlZnM7XG4gICAgdGhpcy5mbiA9IGJ1aWxkZXI7XG4gIH1cbiAgcmVzb2x2ZShiYXNlLCBvcHRpb25zKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMucmVmcy5tYXAocmVmID0+XG4gICAgLy8gVE9ETzogPyBvcGVyYXRvciBoZXJlP1xuICAgIHJlZi5nZXRWYWx1ZShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnZhbHVlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmVudCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0KSk7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMuZm4odmFsdWVzLCBiYXNlLCBvcHRpb25zKTtcbiAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQgfHxcbiAgICAvLyBAdHMtaWdub3JlIHRoaXMgY2FuIGJlIGJhc2VcbiAgICBzY2hlbWEgPT09IGJhc2UpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmRpdGlvbnMgbXVzdCByZXR1cm4gYSBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICB9XG59XG5cbmNvbnN0IHByZWZpeGVzID0ge1xuICBjb250ZXh0OiAnJCcsXG4gIHZhbHVlOiAnLidcbn07XG5mdW5jdGlvbiBjcmVhdGUkOShrZXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoa2V5LCBvcHRpb25zKTtcbn1cbmNsYXNzIFJlZmVyZW5jZSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1ZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNTaWJsaW5nID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmdldHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZiBtdXN0IGJlIGEgc3RyaW5nLCBnb3Q6ICcgKyBrZXkpO1xuICAgIHRoaXMua2V5ID0ga2V5LnRyaW0oKTtcbiAgICBpZiAoa2V5ID09PSAnJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVmIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgdGhpcy5pc0NvbnRleHQgPSB0aGlzLmtleVswXSA9PT0gcHJlZml4ZXMuY29udGV4dDtcbiAgICB0aGlzLmlzVmFsdWUgPSB0aGlzLmtleVswXSA9PT0gcHJlZml4ZXMudmFsdWU7XG4gICAgdGhpcy5pc1NpYmxpbmcgPSAhdGhpcy5pc0NvbnRleHQgJiYgIXRoaXMuaXNWYWx1ZTtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5pc0NvbnRleHQgPyBwcmVmaXhlcy5jb250ZXh0IDogdGhpcy5pc1ZhbHVlID8gcHJlZml4ZXMudmFsdWUgOiAnJztcbiAgICB0aGlzLnBhdGggPSB0aGlzLmtleS5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLmdldHRlciA9IHRoaXMucGF0aCAmJiBnZXR0ZXIodGhpcy5wYXRoLCB0cnVlKTtcbiAgICB0aGlzLm1hcCA9IG9wdGlvbnMubWFwO1xuICB9XG4gIGdldFZhbHVlKHZhbHVlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pc0NvbnRleHQgPyBjb250ZXh0IDogdGhpcy5pc1ZhbHVlID8gdmFsdWUgOiBwYXJlbnQ7XG4gICAgaWYgKHRoaXMuZ2V0dGVyKSByZXN1bHQgPSB0aGlzLmdldHRlcihyZXN1bHQgfHwge30pO1xuICAgIGlmICh0aGlzLm1hcCkgcmVzdWx0ID0gdGhpcy5tYXAocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmNvbnRleHRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLnBhcmVudFxuICAgKi9cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKHZhbHVlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmVudCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0KTtcbiAgfVxuICByZXNvbHZlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2NyaWJlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAncmVmJyxcbiAgICAgIGtleTogdGhpcy5rZXlcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgUmVmKCR7dGhpcy5rZXl9KWA7XG4gIH1cbiAgc3RhdGljIGlzUmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLl9faXNZdXBSZWY7XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZVxuUmVmZXJlbmNlLnByb3RvdHlwZS5fX2lzWXVwUmVmID0gdHJ1ZTtcblxuY29uc3QgaXNBYnNlbnQgPSB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0aW9uKGNvbmZpZykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh7XG4gICAgdmFsdWUsXG4gICAgcGF0aCA9ICcnLFxuICAgIG9wdGlvbnMsXG4gICAgb3JpZ2luYWxWYWx1ZSxcbiAgICBzY2hlbWFcbiAgfSwgcGFuaWMsIG5leHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgdGVzdCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBza2lwQWJzZW50XG4gICAgfSA9IGNvbmZpZztcbiAgICBsZXQge1xuICAgICAgcGFyZW50LFxuICAgICAgY29udGV4dCxcbiAgICAgIGFib3J0RWFybHkgPSBzY2hlbWEuc3BlYy5hYm9ydEVhcmx5LFxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2UgPSBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc29sdmVPcHRpb25zID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBwYXJlbnQsXG4gICAgICBjb250ZXh0XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihvdmVycmlkZXMgPSB7fSkge1xuICAgICAgY29uc3QgbmV4dFBhcmFtcyA9IHJlc29sdmVQYXJhbXMoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBsYWJlbDogc2NoZW1hLnNwZWMubGFiZWwsXG4gICAgICAgIHBhdGg6IG92ZXJyaWRlcy5wYXRoIHx8IHBhdGgsXG4gICAgICAgIHNwZWM6IHNjaGVtYS5zcGVjLFxuICAgICAgICBkaXNhYmxlU3RhY2tUcmFjZTogb3ZlcnJpZGVzLmRpc2FibGVTdGFja1RyYWNlIHx8IGRpc2FibGVTdGFja1RyYWNlXG4gICAgICB9LCBwYXJhbXMsIG92ZXJyaWRlcy5wYXJhbXMpLCByZXNvbHZlT3B0aW9ucyk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG92ZXJyaWRlcy5tZXNzYWdlIHx8IG1lc3NhZ2UsIG5leHRQYXJhbXMpLCB2YWx1ZSwgbmV4dFBhcmFtcy5wYXRoLCBvdmVycmlkZXMudHlwZSB8fCBuYW1lLCBuZXh0UGFyYW1zLmRpc2FibGVTdGFja1RyYWNlKTtcbiAgICAgIGVycm9yLnBhcmFtcyA9IG5leHRQYXJhbXM7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWQgPSBhYm9ydEVhcmx5ID8gcGFuaWMgOiBuZXh0O1xuICAgIGxldCBjdHggPSB7XG4gICAgICBwYXRoLFxuICAgICAgcGFyZW50LFxuICAgICAgdHlwZTogbmFtZSxcbiAgICAgIGZyb206IG9wdGlvbnMuZnJvbSxcbiAgICAgIGNyZWF0ZUVycm9yLFxuICAgICAgcmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTWF5YmVSZWYoaXRlbSwgcmVzb2x2ZU9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgc2NoZW1hXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVSZXN1bHQgPSB2YWxpZE9yRXJyb3IgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKHZhbGlkT3JFcnJvcikpIGludmFsaWQodmFsaWRPckVycm9yKTtlbHNlIGlmICghdmFsaWRPckVycm9yKSBpbnZhbGlkKGNyZWF0ZUVycm9yKCkpO2Vsc2UgbmV4dChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSBpbnZhbGlkKGVycik7ZWxzZSBwYW5pYyhlcnIpO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IHNraXBBYnNlbnQgJiYgaXNBYnNlbnQodmFsdWUpO1xuICAgIGlmIChzaG91bGRTa2lwKSB7XG4gICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHRydWUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3Jlc3VsdDtcbiAgICAgIHJlc3VsdCA9IHRlc3QuY2FsbChjdHgsIHZhbHVlLCBjdHgpO1xuICAgICAgaWYgKHR5cGVvZiAoKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0LnRoZW4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN5bmMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRpb24gdGVzdCBvZiB0eXBlOiBcIiR7Y3R4LnR5cGV9XCIgcmV0dXJuZWQgYSBQcm9taXNlIGR1cmluZyBhIHN5bmNocm9ub3VzIHZhbGlkYXRlLiBgICsgYFRoaXMgdGVzdCB3aWxsIGZpbmlzaCBhZnRlciB0aGUgdmFsaWRhdGUgY2FsbCBoYXMgcmV0dXJuZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihoYW5kbGVSZXN1bHQsIGhhbmRsZUVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICB9XG4gIHZhbGlkYXRlLk9QVElPTlMgPSBjb25maWc7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuLy8gV2FybmluZzogbXV0YXRlcyB0aGUgaW5wdXRcbmZ1bmN0aW9uIHJlc29sdmVQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIGlmICghcGFyYW1zKSByZXR1cm4gcGFyYW1zO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbXMpKSB7XG4gICAgcGFyYW1zW2tleV0gPSByZXNvbHZlTWF5YmVSZWYocGFyYW1zW2tleV0sIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiByZXNvbHZlTWF5YmVSZWYoaXRlbSwgb3B0aW9ucykge1xuICByZXR1cm4gUmVmZXJlbmNlLmlzUmVmKGl0ZW0pID8gaXRlbS5nZXRWYWx1ZShvcHRpb25zLnZhbHVlLCBvcHRpb25zLnBhcmVudCwgb3B0aW9ucy5jb250ZXh0KSA6IGl0ZW07XG59XG5cbmZ1bmN0aW9uIGdldEluKHNjaGVtYSwgcGF0aCwgdmFsdWUsIGNvbnRleHQgPSB2YWx1ZSkge1xuICBsZXQgcGFyZW50LCBsYXN0UGFydCwgbGFzdFBhcnREZWJ1ZztcblxuICAvLyByb290IHBhdGg6ICcnXG4gIGlmICghcGF0aCkgcmV0dXJuIHtcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aDogcGF0aCxcbiAgICBzY2hlbWFcbiAgfTtcbiAgZm9yRWFjaChwYXRoLCAoX3BhcnQsIGlzQnJhY2tldCwgaXNBcnJheSkgPT4ge1xuICAgIGxldCBwYXJ0ID0gaXNCcmFja2V0ID8gX3BhcnQuc2xpY2UoMSwgX3BhcnQubGVuZ3RoIC0gMSkgOiBfcGFydDtcbiAgICBzY2hlbWEgPSBzY2hlbWEucmVzb2x2ZSh7XG4gICAgICBjb250ZXh0LFxuICAgICAgcGFyZW50LFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBsZXQgaXNUdXBsZSA9IHNjaGVtYS50eXBlID09PSAndHVwbGUnO1xuICAgIGxldCBpZHggPSBpc0FycmF5ID8gcGFyc2VJbnQocGFydCwgMTApIDogMDtcbiAgICBpZiAoc2NoZW1hLmlubmVyVHlwZSB8fCBpc1R1cGxlKSB7XG4gICAgICBpZiAoaXNUdXBsZSAmJiAhaXNBcnJheSkgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IGltcGxpY2l0bHkgaW5kZXggaW50byBhIHR1cGxlIHR5cGUuIHRoZSBwYXRoIHBhcnQgXCIke2xhc3RQYXJ0RGVidWd9XCIgbXVzdCBjb250YWluIGFuIGluZGV4IHRvIHRoZSB0dXBsZSBlbGVtZW50LCBlLmcuIFwiJHtsYXN0UGFydERlYnVnfVswXVwiYCk7XG4gICAgICBpZiAodmFsdWUgJiYgaWR4ID49IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFl1cC5yZWFjaCBjYW5ub3QgcmVzb2x2ZSBhbiBhcnJheSBpdGVtIGF0IGluZGV4OiAke19wYXJ0fSwgaW4gdGhlIHBhdGg6ICR7cGF0aH0uIGAgKyBgYmVjYXVzZSB0aGVyZSBpcyBubyB2YWx1ZSBhdCB0aGF0IGluZGV4LiBgKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZVtpZHhdO1xuICAgICAgc2NoZW1hID0gaXNUdXBsZSA/IHNjaGVtYS5zcGVjLnR5cGVzW2lkeF0gOiBzY2hlbWEuaW5uZXJUeXBlO1xuICAgIH1cblxuICAgIC8vIHNvbWV0aW1lcyB0aGUgYXJyYXkgaW5kZXggcGFydCBvZiBhIHBhdGggZG9lc24ndCBleGlzdDogXCJuZXN0ZWQuYXJyLmNoaWxkXCJcbiAgICAvLyBpbiB0aGVzZSBjYXNlcyB0aGUgY3VycmVudCBwYXJ0IGlzIHRoZSBuZXh0IHNjaGVtYSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgIC8vIGluIHRoaXMgaXRlcmF0aW9uLiBGb3IgY2FzZXMgd2hlcmUgdGhlIGluZGV4IHNpZ25hdHVyZSBpcyBpbmNsdWRlZCB0aGlzXG4gICAgLy8gY2hlY2sgd2lsbCBmYWlsIGFuZCB3ZSdsbCBoYW5kbGUgdGhlIGBjaGlsZGAgcGFydCBvbiB0aGUgbmV4dCBpdGVyYXRpb24gbGlrZSBub3JtYWxcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgIGlmICghc2NoZW1hLmZpZWxkcyB8fCAhc2NoZW1hLmZpZWxkc1twYXJ0XSkgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gdGhlIHBhdGg6ICR7cGF0aH0uIGAgKyBgKGZhaWxlZCBhdDogJHtsYXN0UGFydERlYnVnfSB3aGljaCBpcyBhIHR5cGU6IFwiJHtzY2hlbWEudHlwZX1cIilgKTtcbiAgICAgIHBhcmVudCA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZVtwYXJ0XTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5maWVsZHNbcGFydF07XG4gICAgfVxuICAgIGxhc3RQYXJ0ID0gcGFydDtcbiAgICBsYXN0UGFydERlYnVnID0gaXNCcmFja2V0ID8gJ1snICsgX3BhcnQgKyAnXScgOiAnLicgKyBfcGFydDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2NoZW1hLFxuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoOiBsYXN0UGFydFxuICB9O1xufVxuZnVuY3Rpb24gcmVhY2gob2JqLCBwYXRoLCB2YWx1ZSwgY29udGV4dCkge1xuICByZXR1cm4gZ2V0SW4ob2JqLCBwYXRoLCB2YWx1ZSwgY29udGV4dCkuc2NoZW1hO1xufVxuXG5jbGFzcyBSZWZlcmVuY2VTZXQgZXh0ZW5kcyBTZXQge1xuICBkZXNjcmliZSgpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKFJlZmVyZW5jZS5pc1JlZihpdGVtKSA/IGl0ZW0uZGVzY3JpYmUoKSA6IGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH1cbiAgcmVzb2x2ZUFsbChyZXNvbHZlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICByZXN1bHQucHVzaChyZXNvbHZlKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZVNldCh0aGlzLnZhbHVlcygpKTtcbiAgfVxuICBtZXJnZShuZXdJdGVtcywgcmVtb3ZlSXRlbXMpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5ld0l0ZW1zLmZvckVhY2godmFsdWUgPT4gbmV4dC5hZGQodmFsdWUpKTtcbiAgICByZW1vdmVJdGVtcy5mb3JFYWNoKHZhbHVlID0+IG5leHQuZGVsZXRlKHZhbHVlKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn1cblxuLy8gdHdlYWtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9LZWxpbjIwMjUvbmFub2Nsb25lL2Jsb2IvMGFiZWI3NjM1YmRhOWI2OGVmMjI3NzA5M2Y3NmRiZTNiZjM5NDhlMS9zcmMvaW5kZXguanNcbmZ1bmN0aW9uIGNsb25lKHNyYywgc2VlbiA9IG5ldyBNYXAoKSkge1xuICBpZiAoaXNTY2hlbWEoc3JjKSB8fCAhc3JjIHx8IHR5cGVvZiBzcmMgIT09ICdvYmplY3QnKSByZXR1cm4gc3JjO1xuICBpZiAoc2Vlbi5oYXMoc3JjKSkgcmV0dXJuIHNlZW4uZ2V0KHNyYyk7XG4gIGxldCBjb3B5O1xuICBpZiAoc3JjIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIC8vIERhdGVcbiAgICBjb3B5ID0gbmV3IERhdGUoc3JjLmdldFRpbWUoKSk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBSZWdFeHBcbiAgICBjb3B5ID0gbmV3IFJlZ0V4cChzcmMpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBjb3B5ID0gbmV3IEFycmF5KHNyYy5sZW5ndGgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIGNvcHlbaV0gPSBjbG9uZShzcmNbaV0sIHNlZW4pO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIC8vIE1hcFxuICAgIGNvcHkgPSBuZXcgTWFwKCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBzcmMuZW50cmllcygpKSBjb3B5LnNldChrLCBjbG9uZSh2LCBzZWVuKSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgLy8gU2V0XG4gICAgY29weSA9IG5ldyBTZXQoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAoY29uc3QgdiBvZiBzcmMpIGNvcHkuYWRkKGNsb25lKHYsIHNlZW4pKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBPYmplY3RcbiAgICBjb3B5ID0ge307XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzcmMpKSBjb3B5W2tdID0gY2xvbmUodiwgc2Vlbik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBjbG9uZSAke3NyY31gKTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBAc3RhbmRhcmQtc2NoZW1hL3NwZWMgdG8gYXZvaWQgaGF2aW5nIGEgZGVwZW5kZW5jeSBvbiBpdC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFuZGFyZC1zY2hlbWEvc3RhbmRhcmQtc2NoZW1hL2Jsb2IvbWFpbi9wYWNrYWdlcy9zcGVjL3NyYy9pbmRleC50c1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkUGF0aChwYXRoKSB7XG4gIGlmICghKHBhdGggIT0gbnVsbCAmJiBwYXRoLmxlbmd0aCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gQXJyYXkgdG8gc3RvcmUgdGhlIGZpbmFsIHBhdGggc2VnbWVudHNcbiAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgLy8gQnVmZmVyIGZvciBidWlsZGluZyB0aGUgY3VycmVudCBzZWdtZW50XG4gIGxldCBjdXJyZW50U2VnbWVudCA9ICcnO1xuICAvLyBUcmFjayBpZiB3ZSdyZSBpbnNpZGUgc3F1YXJlIGJyYWNrZXRzIChhcnJheS9wcm9wZXJ0eSBhY2Nlc3MpXG4gIGxldCBpbkJyYWNrZXRzID0gZmFsc2U7XG4gIC8vIFRyYWNrIGlmIHdlJ3JlIGluc2lkZSBxdW90ZXMgKGZvciBwcm9wZXJ0eSBuYW1lcyB3aXRoIHNwZWNpYWwgY2hhcnMpXG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcGF0aFtpXTtcbiAgICBpZiAoY2hhciA9PT0gJ1snICYmICFpblF1b3Rlcykge1xuICAgICAgLy8gV2hlbiBlbnRlcmluZyBicmFja2V0cywgcHVzaCBhbnkgYWNjdW11bGF0ZWQgc2VnbWVudCBhZnRlciBzcGxpdHRpbmcgb24gZG90c1xuICAgICAgaWYgKGN1cnJlbnRTZWdtZW50KSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goLi4uY3VycmVudFNlZ21lbnQuc3BsaXQoJy4nKS5maWx0ZXIoQm9vbGVhbikpO1xuICAgICAgICBjdXJyZW50U2VnbWVudCA9ICcnO1xuICAgICAgfVxuICAgICAgaW5CcmFja2V0cyA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09ICddJyAmJiAhaW5RdW90ZXMpIHtcbiAgICAgIGlmIChjdXJyZW50U2VnbWVudCkge1xuICAgICAgICAvLyBIYW5kbGUgbnVtZXJpYyBpbmRpY2VzIChlLmcuIGFyclswXSlcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QoY3VycmVudFNlZ21lbnQpKSB7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChjdXJyZW50U2VnbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSGFuZGxlIHF1b3RlZCBwcm9wZXJ0eSBuYW1lcyAoZS5nLiBvYmpbXCJmb28uYmFyXCJdKVxuICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VycmVudFNlZ21lbnQucmVwbGFjZSgvXlwifFwiJC9nLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRTZWdtZW50ID0gJyc7XG4gICAgICB9XG4gICAgICBpbkJyYWNrZXRzID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgIC8vIFRvZ2dsZSBxdW90ZSBzdGF0ZSBmb3IgaGFuZGxpbmcgcXVvdGVkIHByb3BlcnR5IG5hbWVzXG4gICAgICBpblF1b3RlcyA9ICFpblF1b3RlcztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gJy4nICYmICFpbkJyYWNrZXRzICYmICFpblF1b3Rlcykge1xuICAgICAgLy8gT24gZG90cyBvdXRzaWRlIGJyYWNrZXRzL3F1b3RlcywgcHVzaCBjdXJyZW50IHNlZ21lbnRcbiAgICAgIGlmIChjdXJyZW50U2VnbWVudCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnRTZWdtZW50KTtcbiAgICAgICAgY3VycmVudFNlZ21lbnQgPSAnJztcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjdXJyZW50U2VnbWVudCArPSBjaGFyO1xuICB9XG5cbiAgLy8gUHVzaCBhbnkgcmVtYWluaW5nIHNlZ21lbnQgYWZ0ZXIgc3BsaXR0aW5nIG9uIGRvdHNcbiAgaWYgKGN1cnJlbnRTZWdtZW50KSB7XG4gICAgc2VnbWVudHMucHVzaCguLi5jdXJyZW50U2VnbWVudC5zcGxpdCgnLicpLmZpbHRlcihCb29sZWFuKSk7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRJc3N1ZXMoZXJyb3IsIHBhcmVudFBhdGgpIHtcbiAgY29uc3QgcGF0aCA9IHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS4ke2Vycm9yLnBhdGh9YCA6IGVycm9yLnBhdGg7XG4gIHJldHVybiBlcnJvci5lcnJvcnMubWFwKGVyciA9PiAoe1xuICAgIG1lc3NhZ2U6IGVycixcbiAgICBwYXRoOiBjcmVhdGVTdGFuZGFyZFBhdGgocGF0aClcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNzdWVzRnJvbVZhbGlkYXRpb25FcnJvcihlcnJvciwgcGFyZW50UGF0aCkge1xuICB2YXIgX2Vycm9yJGlubmVyO1xuICBpZiAoISgoX2Vycm9yJGlubmVyID0gZXJyb3IuaW5uZXIpICE9IG51bGwgJiYgX2Vycm9yJGlubmVyLmxlbmd0aCkgJiYgZXJyb3IuZXJyb3JzLmxlbmd0aCkge1xuICAgIHJldHVybiBjcmVhdGVTdGFuZGFyZElzc3VlcyhlcnJvciwgcGFyZW50UGF0aCk7XG4gIH1cbiAgY29uc3QgcGF0aCA9IHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS4ke2Vycm9yLnBhdGh9YCA6IGVycm9yLnBhdGg7XG4gIHJldHVybiBlcnJvci5pbm5lci5mbGF0TWFwKGVyciA9PiBpc3N1ZXNGcm9tVmFsaWRhdGlvbkVycm9yKGVyciwgcGF0aCkpO1xufVxuXG4vLyBJZiBgQ3VzdG9tU2NoZW1hTWV0YWAgaXNuJ3QgZXh0ZW5kZWQgd2l0aCBhbnkga2V5cywgd2UnbGwgZmFsbCBiYWNrIHRvIGFcbi8vIGxvb3NlIFJlY29yZCBkZWZpbml0aW9uIGFsbG93aW5nIGZyZWUgZm9ybSB1c2FnZS5cbmNsYXNzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy50ZXN0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25kaXRpb25zID0gW107XG4gICAgdGhpcy5fbXV0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJuYWxUZXN0cyA9IHt9O1xuICAgIHRoaXMuX3doaXRlbGlzdCA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcbiAgICB0aGlzLl9ibGFja2xpc3QgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgdGhpcy5leGNsdXNpdmVUZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fdHlwZUNoZWNrID0gdm9pZCAwO1xuICAgIHRoaXMuc3BlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnRlc3RzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50eXBlRXJyb3IobWl4ZWQubm90VHlwZSk7XG4gICAgfSk7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHRoaXMuX3R5cGVDaGVjayA9IG9wdGlvbnMuY2hlY2s7XG4gICAgdGhpcy5zcGVjID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzdHJpcDogZmFsc2UsXG4gICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgIGRpc2FibGVTdGFja1RyYWNlOiBmYWxzZSxcbiAgICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY29lcmNlOiB0cnVlXG4gICAgfSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zcGVjKTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbihzID0+IHtcbiAgICAgIHMubm9uTnVsbGFibGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlbW92ZVxuICBnZXQgX3R5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgaWYgKHRoaXMuX211dGF0ZSkge1xuICAgICAgaWYgKHNwZWMpIE9iamVjdC5hc3NpZ24odGhpcy5zcGVjLCBzcGVjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBuZXN0ZWQgdmFsdWUgaXMgYSBzY2hlbWEgd2UgY2FuIHNraXAgY2xvbmluZywgc2luY2VcbiAgICAvLyB0aGV5IGFyZSBhbHJlYWR5IGltbXV0YWJsZVxuICAgIGNvbnN0IG5leHQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgcmVhZG9ubHlcbiAgICBuZXh0LnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgbmV4dC5fdHlwZUNoZWNrID0gdGhpcy5fdHlwZUNoZWNrO1xuICAgIG5leHQuX3doaXRlbGlzdCA9IHRoaXMuX3doaXRlbGlzdC5jbG9uZSgpO1xuICAgIG5leHQuX2JsYWNrbGlzdCA9IHRoaXMuX2JsYWNrbGlzdC5jbG9uZSgpO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxUZXN0cyk7XG4gICAgbmV4dC5leGNsdXNpdmVUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXhjbHVzaXZlVGVzdHMpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIHJlYWRvbmx5XG4gICAgbmV4dC5kZXBzID0gWy4uLnRoaXMuZGVwc107XG4gICAgbmV4dC5jb25kaXRpb25zID0gWy4uLnRoaXMuY29uZGl0aW9uc107XG4gICAgbmV4dC50ZXN0cyA9IFsuLi50aGlzLnRlc3RzXTtcbiAgICBuZXh0LnRyYW5zZm9ybXMgPSBbLi4udGhpcy50cmFuc2Zvcm1zXTtcbiAgICBuZXh0LnNwZWMgPSBjbG9uZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNwZWMsIHNwZWMpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBsYWJlbChsYWJlbCkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5sYWJlbCA9IGxhYmVsO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG1ldGEoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuc3BlYy5tZXRhO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5tZXRhID0gT2JqZWN0LmFzc2lnbihuZXh0LnNwZWMubWV0YSB8fCB7fSwgYXJnc1swXSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgd2l0aE11dGF0aW9uKGZuKSB7XG4gICAgbGV0IGJlZm9yZSA9IHRoaXMuX211dGF0ZTtcbiAgICB0aGlzLl9tdXRhdGUgPSB0cnVlO1xuICAgIGxldCByZXN1bHQgPSBmbih0aGlzKTtcbiAgICB0aGlzLl9tdXRhdGUgPSBiZWZvcmU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25jYXQoc2NoZW1hKSB7XG4gICAgaWYgKCFzY2hlbWEgfHwgc2NoZW1hID09PSB0aGlzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoc2NoZW1hLnR5cGUgIT09IHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBjYW5ub3QgXFxgY29uY2F0KClcXGAgc2NoZW1hJ3Mgb2YgZGlmZmVyZW50IHR5cGVzOiAke3RoaXMudHlwZX0gYW5kICR7c2NoZW1hLnR5cGV9YCk7XG4gICAgbGV0IGJhc2UgPSB0aGlzO1xuICAgIGxldCBjb21iaW5lZCA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIGNvbnN0IG1lcmdlZFNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlLnNwZWMsIGNvbWJpbmVkLnNwZWMpO1xuICAgIGNvbWJpbmVkLnNwZWMgPSBtZXJnZWRTcGVjO1xuICAgIGNvbWJpbmVkLmludGVybmFsVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlLmludGVybmFsVGVzdHMsIGNvbWJpbmVkLmludGVybmFsVGVzdHMpO1xuXG4gICAgLy8gbWFudWFsbHkgbWVyZ2UgdGhlIGJsYWNrbGlzdC93aGl0ZWxpc3QgKHRoZSBvdGhlciBgc2NoZW1hYCB0YWtlc1xuICAgIC8vIHByZWNlZGVuY2UgaW4gY2FzZSBvZiBjb25mbGljdHMpXG4gICAgY29tYmluZWQuX3doaXRlbGlzdCA9IGJhc2UuX3doaXRlbGlzdC5tZXJnZShzY2hlbWEuX3doaXRlbGlzdCwgc2NoZW1hLl9ibGFja2xpc3QpO1xuICAgIGNvbWJpbmVkLl9ibGFja2xpc3QgPSBiYXNlLl9ibGFja2xpc3QubWVyZ2Uoc2NoZW1hLl9ibGFja2xpc3QsIHNjaGVtYS5fd2hpdGVsaXN0KTtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGN1cnJlbnQgdGVzdHNcbiAgICBjb21iaW5lZC50ZXN0cyA9IGJhc2UudGVzdHM7XG4gICAgY29tYmluZWQuZXhjbHVzaXZlVGVzdHMgPSBiYXNlLmV4Y2x1c2l2ZVRlc3RzO1xuXG4gICAgLy8gbWFudWFsbHkgYWRkIHRoZSBuZXcgdGVzdHMgdG8gZW5zdXJlXG4gICAgLy8gdGhlIGRlZHVwaW5nIGxvZ2ljIGlzIGNvbnNpc3RlbnRcbiAgICBjb21iaW5lZC53aXRoTXV0YXRpb24obmV4dCA9PiB7XG4gICAgICBzY2hlbWEudGVzdHMuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgIG5leHQudGVzdChmbi5PUFRJT05TKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbWJpbmVkLnRyYW5zZm9ybXMgPSBbLi4uYmFzZS50cmFuc2Zvcm1zLCAuLi5jb21iaW5lZC50cmFuc2Zvcm1zXTtcbiAgICByZXR1cm4gY29tYmluZWQ7XG4gIH1cbiAgaXNUeXBlKHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5zcGVjLm51bGxhYmxlICYmIHYgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCAmJiB2ID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHlwZUNoZWNrKHYpO1xuICB9XG4gIHJlc29sdmUob3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSB0aGlzO1xuICAgIGlmIChzY2hlbWEuY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGxldCBjb25kaXRpb25zID0gc2NoZW1hLmNvbmRpdGlvbnM7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgICAgIHNjaGVtYS5jb25kaXRpb25zID0gW107XG4gICAgICBzY2hlbWEgPSBjb25kaXRpb25zLnJlZHVjZSgocHJldlNjaGVtYSwgY29uZGl0aW9uKSA9PiBjb25kaXRpb24ucmVzb2x2ZShwcmV2U2NoZW1hLCBvcHRpb25zKSwgc2NoZW1hKTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIHJlc29sdmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkc3RyaWN0LCBfb3B0aW9ucyRhYm9ydEVhcmx5LCBfb3B0aW9ucyRyZWN1cnNpdmUsIF9vcHRpb25zJGRpc2FibGVTdGFjaztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgZnJvbTogb3B0aW9ucy5mcm9tIHx8IFtdLFxuICAgICAgc3RyaWN0OiAoX29wdGlvbnMkc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QpICE9IG51bGwgPyBfb3B0aW9ucyRzdHJpY3QgOiB0aGlzLnNwZWMuc3RyaWN0LFxuICAgICAgYWJvcnRFYXJseTogKF9vcHRpb25zJGFib3J0RWFybHkgPSBvcHRpb25zLmFib3J0RWFybHkpICE9IG51bGwgPyBfb3B0aW9ucyRhYm9ydEVhcmx5IDogdGhpcy5zcGVjLmFib3J0RWFybHksXG4gICAgICByZWN1cnNpdmU6IChfb3B0aW9ucyRyZWN1cnNpdmUgPSBvcHRpb25zLnJlY3Vyc2l2ZSkgIT0gbnVsbCA/IF9vcHRpb25zJHJlY3Vyc2l2ZSA6IHRoaXMuc3BlYy5yZWN1cnNpdmUsXG4gICAgICBkaXNhYmxlU3RhY2tUcmFjZTogKF9vcHRpb25zJGRpc2FibGVTdGFjayA9IG9wdGlvbnMuZGlzYWJsZVN0YWNrVHJhY2UpICE9IG51bGwgPyBfb3B0aW9ucyRkaXNhYmxlU3RhY2sgOiB0aGlzLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIGNvbmZpZ3VyZWQgdHJhbnNmb3JtIHBpcGVsaW5lIG92ZXIgYW4gaW5wdXQgdmFsdWUuXG4gICAqL1xuXG4gIGNhc3QodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCByZXNvbHZlZFNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHZhbHVlXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIGxldCBhbGxvd09wdGlvbmFsaXR5ID0gb3B0aW9ucy5hc3NlcnQgPT09ICdpZ25vcmUtb3B0aW9uYWxpdHknO1xuICAgIGxldCByZXN1bHQgPSByZXNvbHZlZFNjaGVtYS5fY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuYXNzZXJ0ICE9PSBmYWxzZSAmJiAhcmVzb2x2ZWRTY2hlbWEuaXNUeXBlKHJlc3VsdCkpIHtcbiAgICAgIGlmIChhbGxvd09wdGlvbmFsaXR5ICYmIGlzQWJzZW50KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXR0ZWRWYWx1ZSA9IHByaW50VmFsdWUodmFsdWUpO1xuICAgICAgbGV0IGZvcm1hdHRlZFJlc3VsdCA9IHByaW50VmFsdWUocmVzdWx0KTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSB2YWx1ZSBvZiAke29wdGlvbnMucGF0aCB8fCAnZmllbGQnfSBjb3VsZCBub3QgYmUgY2FzdCB0byBhIHZhbHVlIGAgKyBgdGhhdCBzYXRpc2ZpZXMgdGhlIHNjaGVtYSB0eXBlOiBcIiR7cmVzb2x2ZWRTY2hlbWEudHlwZX1cIi4gXFxuXFxuYCArIGBhdHRlbXB0ZWQgdmFsdWU6ICR7Zm9ybWF0dGVkVmFsdWV9IFxcbmAgKyAoZm9ybWF0dGVkUmVzdWx0ICE9PSBmb3JtYXR0ZWRWYWx1ZSA/IGByZXN1bHQgb2YgY2FzdDogJHtmb3JtYXR0ZWRSZXN1bHR9YCA6ICcnKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX2Nhc3QocmF3VmFsdWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWUgPSByYXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gcmF3VmFsdWUgOiB0aGlzLnRyYW5zZm9ybXMucmVkdWNlKChwcmV2VmFsdWUsIGZuKSA9PiBmbi5jYWxsKHRoaXMsIHByZXZWYWx1ZSwgcmF3VmFsdWUsIHRoaXMpLCByYXdWYWx1ZSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCB7XG4gICAgICBwYXRoLFxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IF92YWx1ZSxcbiAgICAgIHN0cmljdCA9IHRoaXMuc3BlYy5zdHJpY3RcbiAgICB9ID0gb3B0aW9ucztcbiAgICBsZXQgdmFsdWUgPSBfdmFsdWU7XG4gICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY2FzdCh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGFzc2VydDogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgbGV0IGluaXRpYWxUZXN0cyA9IFtdO1xuICAgIGZvciAobGV0IHRlc3Qgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmludGVybmFsVGVzdHMpKSB7XG4gICAgICBpZiAodGVzdCkgaW5pdGlhbFRlc3RzLnB1c2godGVzdCk7XG4gICAgfVxuICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB0ZXN0czogaW5pdGlhbFRlc3RzXG4gICAgfSwgcGFuaWMsIGluaXRpYWxFcnJvcnMgPT4ge1xuICAgICAgLy8gZXZlbiBpZiB3ZSBhcmVuJ3QgZW5kaW5nIGVhcmx5IHdlIGNhbid0IHByb2NlZWQgZnVydGhlciBpZiB0aGUgdHlwZXMgYXJlbid0IGNvcnJlY3RcbiAgICAgIGlmIChpbml0aWFsRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV4dChpbml0aWFsRXJyb3JzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHRlc3RzOiB0aGlzLnRlc3RzXG4gICAgICB9LCBwYW5pYywgbmV4dCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBzZXQgb2YgdmFsaWRhdGlvbnMsIGVpdGhlciBzY2hlbWEsIHByb2R1Y2VkIFRlc3RzIG9yIGEgbmVzdGVkXG4gICAqIHNjaGVtYSB2YWxpZGF0ZSByZXN1bHQuXG4gICAqL1xuICBydW5UZXN0cyhydW5PcHRpb25zLCBwYW5pYywgbmV4dCkge1xuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xuICAgIGxldCB7XG4gICAgICB0ZXN0cyxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIHBhdGgsXG4gICAgICBvcHRpb25zXG4gICAgfSA9IHJ1bk9wdGlvbnM7XG4gICAgbGV0IHBhbmljT25jZSA9IGFyZyA9PiB7XG4gICAgICBpZiAoZmlyZWQpIHJldHVybjtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIHBhbmljKGFyZywgdmFsdWUpO1xuICAgIH07XG4gICAgbGV0IG5leHRPbmNlID0gYXJnID0+IHtcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbmV4dChhcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGxldCBjb3VudCA9IHRlc3RzLmxlbmd0aDtcbiAgICBsZXQgbmVzdGVkRXJyb3JzID0gW107XG4gICAgaWYgKCFjb3VudCkgcmV0dXJuIG5leHRPbmNlKFtdKTtcbiAgICBsZXQgYXJncyA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIHBhdGgsXG4gICAgICBvcHRpb25zLFxuICAgICAgc2NoZW1hOiB0aGlzXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXN0ID0gdGVzdHNbaV07XG4gICAgICB0ZXN0KGFyZ3MsIHBhbmljT25jZSwgZnVuY3Rpb24gZmluaXNoVGVzdFJ1bihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkoZXJyKSA/IG5lc3RlZEVycm9ycy5wdXNoKC4uLmVycikgOiBuZXN0ZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgtLWNvdW50IDw9IDApIHtcbiAgICAgICAgICBuZXh0T25jZShuZXN0ZWRFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXNOZXN0ZWRUZXN0KHtcbiAgICBrZXksXG4gICAgaW5kZXgsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgb3JpZ2luYWxQYXJlbnQsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgY29uc3QgayA9IGtleSAhPSBudWxsID8ga2V5IDogaW5kZXg7XG4gICAgaWYgKGsgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdNdXN0IGluY2x1ZGUgYGtleWAgb3IgYGluZGV4YCBmb3IgbmVzdGVkIHZhbGlkYXRpb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW5kZXggPSB0eXBlb2YgayA9PT0gJ251bWJlcic7XG4gICAgbGV0IHZhbHVlID0gcGFyZW50W2tdO1xuICAgIGNvbnN0IHRlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgLy8gTmVzdGVkIHZhbGlkYXRpb25zIGZpZWxkcyBhcmUgYWx3YXlzIHN0cmljdDpcbiAgICAgIC8vICAgIDEuIHBhcmVudCBpc24ndCBzdHJpY3Qgc28gdGhlIGNhc3Rpbmcgd2lsbCBhbHNvIGhhdmUgY2FzdCBpbm5lciB2YWx1ZXNcbiAgICAgIC8vICAgIDIuIHBhcmVudCBpcyBzdHJpY3QgaW4gd2hpY2ggY2FzZSB0aGUgbmVzdGVkIHZhbHVlcyB3ZXJlbid0IGNhc3QgZWl0aGVyXG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBwYXJlbnQsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9yaWdpbmFsVmFsdWU6IG9yaWdpbmFsUGFyZW50W2tdLFxuICAgICAgLy8gRklYTUU6IHRlc3RzIGRlcGVuZCBvbiBgaW5kZXhgIGJlaW5nIHBhc3NlZCBhcm91bmQgZGVlcGx5LFxuICAgICAgLy8gICB3ZSBzaG91bGQgbm90IGxldCB0aGUgb3B0aW9ucy5rZXkvaW5kZXggYmxlZWQgdGhyb3VnaFxuICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAvLyBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgW2lzSW5kZXggPyAnaW5kZXgnIDogJ2tleSddOiBrLFxuICAgICAgcGF0aDogaXNJbmRleCB8fCBrLmluY2x1ZGVzKCcuJykgPyBgJHtwYXJlbnRQYXRoIHx8ICcnfVske2lzSW5kZXggPyBrIDogYFwiJHtrfVwiYH1dYCA6IChwYXJlbnRQYXRoID8gYCR7cGFyZW50UGF0aH0uYCA6ICcnKSArIGtleVxuICAgIH0pO1xuICAgIHJldHVybiAoXywgcGFuaWMsIG5leHQpID0+IHRoaXMucmVzb2x2ZSh0ZXN0T3B0aW9ucykuX3ZhbGlkYXRlKHZhbHVlLCB0ZXN0T3B0aW9ucywgcGFuaWMsIG5leHQpO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJGRpc2FibGVTdGFjazI7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZVxuICAgIH0pKTtcbiAgICBsZXQgZGlzYWJsZVN0YWNrVHJhY2UgPSAoX29wdGlvbnMkZGlzYWJsZVN0YWNrMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZVN0YWNrVHJhY2UpICE9IG51bGwgPyBfb3B0aW9ucyRkaXNhYmxlU3RhY2syIDogc2NoZW1hLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2U7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNjaGVtYS5fdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMsIChlcnJvciwgcGFyc2VkKSA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyb3IpKSBlcnJvci52YWx1ZSA9IHBhcnNlZDtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSwgKGVycm9ycywgdmFsaWRhdGVkKSA9PiB7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgcmVqZWN0KG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCB2YWxpZGF0ZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkaXNhYmxlU3RhY2tUcmFjZSkpO2Vsc2UgcmVzb2x2ZSh2YWxpZGF0ZWQpO1xuICAgIH0pKTtcbiAgfVxuICB2YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkZGlzYWJsZVN0YWNrMztcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlXG4gICAgfSkpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGRpc2FibGVTdGFja1RyYWNlID0gKF9vcHRpb25zJGRpc2FibGVTdGFjazMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVTdGFja1RyYWNlKSAhPSBudWxsID8gX29wdGlvbnMkZGlzYWJsZVN0YWNrMyA6IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlO1xuICAgIHNjaGVtYS5fdmFsaWRhdGUodmFsdWUsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHN5bmM6IHRydWVcbiAgICB9KSwgKGVycm9yLCBwYXJzZWQpID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnJvcikpIGVycm9yLnZhbHVlID0gcGFyc2VkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSwgKGVycm9ycywgdmFsaWRhdGVkKSA9PiB7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMsIHZhbHVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGlzYWJsZVN0YWNrVHJhY2UpO1xuICAgICAgcmVzdWx0ID0gdmFsaWRhdGVkO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKS50aGVuKCgpID0+IHRydWUsIGVyciA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG4gIGlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgX2dldERlZmF1bHQob3B0aW9ucykge1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSB0aGlzLnNwZWMuZGVmYXVsdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nID8gZGVmYXVsdFZhbHVlLmNhbGwodGhpcywgb3B0aW9ucykgOiBjbG9uZShkZWZhdWx0VmFsdWUpO1xuICB9XG4gIGdldERlZmF1bHQob3B0aW9uc1xuICAvLyBJZiBzY2hlbWEgaXMgZGVmYXVsdGVkIHdlIGtub3cgaXQncyBhdCBsZWFzdCBub3QgdW5kZWZpbmVkXG4gICkge1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUob3B0aW9ucyB8fCB7fSk7XG4gICAgcmV0dXJuIHNjaGVtYS5fZ2V0RGVmYXVsdChvcHRpb25zKTtcbiAgfVxuICBkZWZhdWx0KGRlZikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGVmYXVsdCgpO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgZGVmYXVsdDogZGVmXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgc3RyaWN0KGlzU3RyaWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHtcbiAgICAgIHN0cmljdDogaXNTdHJpY3RcbiAgICB9KTtcbiAgfVxuICBudWxsYWJpbGl0eShudWxsYWJsZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIG51bGxhYmxlXG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLm51bGxhYmxlID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ251bGxhYmxlJyxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gdGhpcy5zY2hlbWEuc3BlYy5udWxsYWJsZSA6IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWxpdHkob3B0aW9uYWwsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBvcHRpb25hbFxuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5vcHRpb25hbGl0eSA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdvcHRpb25hbGl0eScsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5zY2hlbWEuc3BlYy5vcHRpb25hbCA6IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkodHJ1ZSk7XG4gIH1cbiAgZGVmaW5lZChtZXNzYWdlID0gbWl4ZWQuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxuICBudWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5udWxsYWJpbGl0eSh0cnVlKTtcbiAgfVxuICBub25OdWxsYWJsZShtZXNzYWdlID0gbWl4ZWQubm90TnVsbCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmlsaXR5KGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxuICByZXF1aXJlZChtZXNzYWdlID0gbWl4ZWQucmVxdWlyZWQpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IG5leHQubm9uTnVsbGFibGUobWVzc2FnZSkuZGVmaW5lZChtZXNzYWdlKSk7XG4gIH1cbiAgbm90UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS53aXRoTXV0YXRpb24obmV4dCA9PiBuZXh0Lm51bGxhYmxlKCkub3B0aW9uYWwoKSk7XG4gIH1cbiAgdHJhbnNmb3JtKGZuKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC50cmFuc2Zvcm1zLnB1c2goZm4pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0ZXN0IGZ1bmN0aW9uIHRvIHRoZSBzY2hlbWEncyBxdWV1ZSBvZiB0ZXN0cy5cbiAgICogdGVzdHMgY2FuIGJlIGV4Y2x1c2l2ZSBvciBub24tZXhjbHVzaXZlLlxuICAgKlxuICAgKiAtIGV4Y2x1c2l2ZSB0ZXN0cywgd2lsbCByZXBsYWNlIGFueSBleGlzdGluZyB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lLlxuICAgKiAtIG5vbi1leGNsdXNpdmU6IGNhbiBiZSBzdGFja2VkXG4gICAqXG4gICAqIElmIGEgbm9uLWV4Y2x1c2l2ZSB0ZXN0IGlzIGFkZGVkIHRvIGEgc2NoZW1hIHdpdGggYW4gZXhjbHVzaXZlIHRlc3Qgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiB0aGUgZXhjbHVzaXZlIHRlc3QgaXMgcmVtb3ZlZCBhbmQgZnVydGhlciB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lIHdpbGwgYmUgc3RhY2tlZC5cbiAgICpcbiAgICogSWYgYW4gZXhjbHVzaXZlIHRlc3QgaXMgYWRkZWQgdG8gYSBzY2hlbWEgd2l0aCBub24tZXhjbHVzaXZlIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogdGhlIHByZXZpb3VzIHRlc3RzIGFyZSByZW1vdmVkIGFuZCBmdXJ0aGVyIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUgd2lsbCByZXBsYWNlIGVhY2ggb3RoZXIuXG4gICAqL1xuXG4gIHRlc3QoLi4uYXJncykge1xuICAgIGxldCBvcHRzO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgdGVzdDogYXJnc1swXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cyA9IGFyZ3NbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgbmFtZTogYXJnc1swXSxcbiAgICAgICAgdGVzdDogYXJnc1sxXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgbmFtZTogYXJnc1swXSxcbiAgICAgICAgbWVzc2FnZTogYXJnc1sxXSxcbiAgICAgICAgdGVzdDogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdHMubWVzc2FnZSA9PT0gdW5kZWZpbmVkKSBvcHRzLm1lc3NhZ2UgPSBtaXhlZC5kZWZhdWx0O1xuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0ICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdGVzdGAgaXMgYSByZXF1aXJlZCBwYXJhbWV0ZXJzJyk7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbGV0IHZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdGlvbihvcHRzKTtcbiAgICBsZXQgaXNFeGNsdXNpdmUgPSBvcHRzLmV4Y2x1c2l2ZSB8fCBvcHRzLm5hbWUgJiYgbmV4dC5leGNsdXNpdmVUZXN0c1tvcHRzLm5hbWVdID09PSB0cnVlO1xuICAgIGlmIChvcHRzLmV4Y2x1c2l2ZSkge1xuICAgICAgaWYgKCFvcHRzLm5hbWUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2x1c2l2ZSB0ZXN0cyBtdXN0IHByb3ZpZGUgYSB1bmlxdWUgYG5hbWVgIGlkZW50aWZ5aW5nIHRoZSB0ZXN0Jyk7XG4gICAgfVxuICAgIGlmIChvcHRzLm5hbWUpIG5leHQuZXhjbHVzaXZlVGVzdHNbb3B0cy5uYW1lXSA9ICEhb3B0cy5leGNsdXNpdmU7XG4gICAgbmV4dC50ZXN0cyA9IG5leHQudGVzdHMuZmlsdGVyKGZuID0+IHtcbiAgICAgIGlmIChmbi5PUFRJT05TLm5hbWUgPT09IG9wdHMubmFtZSkge1xuICAgICAgICBpZiAoaXNFeGNsdXNpdmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZuLk9QVElPTlMudGVzdCA9PT0gdmFsaWRhdGUuT1BUSU9OUy50ZXN0KSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBuZXh0LnRlc3RzLnB1c2godmFsaWRhdGUpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHdoZW4oa2V5cywgb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSAmJiB0eXBlb2Yga2V5cyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSBrZXlzO1xuICAgICAga2V5cyA9ICcuJztcbiAgICB9XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbGV0IGRlcHMgPSB0b0FycmF5KGtleXMpLm1hcChrZXkgPT4gbmV3IFJlZmVyZW5jZShrZXkpKTtcbiAgICBkZXBzLmZvckVhY2goZGVwID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcmVhZG9ubHkgYXJyYXlcbiAgICAgIGlmIChkZXAuaXNTaWJsaW5nKSBuZXh0LmRlcHMucHVzaChkZXAua2V5KTtcbiAgICB9KTtcbiAgICBuZXh0LmNvbmRpdGlvbnMucHVzaCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBDb25kaXRpb24oZGVwcywgb3B0aW9ucykgOiBDb25kaXRpb24uZnJvbU9wdGlvbnMoZGVwcywgb3B0aW9ucykpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLnR5cGVFcnJvciA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICd0eXBlRXJyb3InLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNjaGVtYS5fdHlwZUNoZWNrKHZhbHVlKSkgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5zY2hlbWEudHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9uZU9mKGVudW1zLCBtZXNzYWdlID0gbWl4ZWQub25lT2YpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBlbnVtcy5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICBuZXh0Ll93aGl0ZWxpc3QuYWRkKHZhbCk7XG4gICAgICBuZXh0Ll9ibGFja2xpc3QuZGVsZXRlKHZhbCk7XG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLndoaXRlTGlzdCA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdvbmVPZicsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBsZXQgdmFsaWRzID0gdGhpcy5zY2hlbWEuX3doaXRlbGlzdDtcbiAgICAgICAgbGV0IHJlc29sdmVkID0gdmFsaWRzLnJlc29sdmVBbGwodGhpcy5yZXNvbHZlKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkLmluY2x1ZGVzKHZhbHVlKSA/IHRydWUgOiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHZhbHVlczogQXJyYXkuZnJvbSh2YWxpZHMpLmpvaW4oJywgJyksXG4gICAgICAgICAgICByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbm90T25lT2YoZW51bXMsIG1lc3NhZ2UgPSBtaXhlZC5ub3RPbmVPZikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGVudW1zLmZvckVhY2godmFsID0+IHtcbiAgICAgIG5leHQuX2JsYWNrbGlzdC5hZGQodmFsKTtcbiAgICAgIG5leHQuX3doaXRlbGlzdC5kZWxldGUodmFsKTtcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMuYmxhY2tsaXN0ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ25vdE9uZU9mJyxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgbGV0IGludmFsaWRzID0gdGhpcy5zY2hlbWEuX2JsYWNrbGlzdDtcbiAgICAgICAgbGV0IHJlc29sdmVkID0gaW52YWxpZHMucmVzb2x2ZUFsbCh0aGlzLnJlc29sdmUpO1xuICAgICAgICBpZiAocmVzb2x2ZWQuaW5jbHVkZXModmFsdWUpKSByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IEFycmF5LmZyb20oaW52YWxpZHMpLmpvaW4oJywgJyksXG4gICAgICAgICAgICByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHN0cmlwKHN0cmlwID0gdHJ1ZSkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5zdHJpcCA9IHN0cmlwO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHNlcmlhbGl6ZWQgZGVzY3JpcHRpb24gb2YgdGhlIHNjaGVtYSBpbmNsdWRpbmcgdmFsaWRhdGlvbnMsIGZsYWdzLCB0eXBlcyBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFByb3ZpZGUgYW55IG5lZWRlZCBjb250ZXh0IGZvciByZXNvbHZpbmcgcnVudGltZSBzY2hlbWEgYWx0ZXJhdGlvbnMgKGxhenksIHdoZW4gY29uZGl0aW9ucywgZXRjKS5cbiAgICovXG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsLFxuICAgICAgbWV0YSxcbiAgICAgIG9wdGlvbmFsLFxuICAgICAgbnVsbGFibGVcbiAgICB9ID0gbmV4dC5zcGVjO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGxhYmVsLFxuICAgICAgb3B0aW9uYWwsXG4gICAgICBudWxsYWJsZSxcbiAgICAgIGRlZmF1bHQ6IG5leHQuZ2V0RGVmYXVsdChvcHRpb25zKSxcbiAgICAgIHR5cGU6IG5leHQudHlwZSxcbiAgICAgIG9uZU9mOiBuZXh0Ll93aGl0ZWxpc3QuZGVzY3JpYmUoKSxcbiAgICAgIG5vdE9uZU9mOiBuZXh0Ll9ibGFja2xpc3QuZGVzY3JpYmUoKSxcbiAgICAgIHRlc3RzOiBuZXh0LnRlc3RzLmZpbHRlcigobiwgaWR4LCBsaXN0KSA9PiBsaXN0LmZpbmRJbmRleChjID0+IGMuT1BUSU9OUy5uYW1lID09PSBuLk9QVElPTlMubmFtZSkgPT09IGlkeCkubWFwKGZuID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gZm4uT1BUSU9OUy5wYXJhbXMgJiYgb3B0aW9ucyA/IHJlc29sdmVQYXJhbXMoT2JqZWN0LmFzc2lnbih7fSwgZm4uT1BUSU9OUy5wYXJhbXMpLCBvcHRpb25zKSA6IGZuLk9QVElPTlMucGFyYW1zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGZuLk9QVElPTlMubmFtZSxcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH1cbiAgZ2V0IFsnfnN0YW5kYXJkJ10oKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcztcbiAgICBjb25zdCBzdGFuZGFyZCA9IHtcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICB2ZW5kb3I6ICd5dXAnLFxuICAgICAgYXN5bmMgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEudmFsaWRhdGUodmFsdWUsIHtcbiAgICAgICAgICAgIGFib3J0RWFybHk6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpc3N1ZXM6IGlzc3Vlc0Zyb21WYWxpZGF0aW9uRXJyb3IoZXJyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc3RhbmRhcmQ7XG4gIH1cbn1cbi8vIEB0cy1leHBlY3QtZXJyb3JcblNjaGVtYS5wcm90b3R5cGUuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIFsndmFsaWRhdGUnLCAndmFsaWRhdGVTeW5jJ10pIFNjaGVtYS5wcm90b3R5cGVbYCR7bWV0aG9kfUF0YF0gPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgc2NoZW1hXG4gIH0gPSBnZXRJbih0aGlzLCBwYXRoLCB2YWx1ZSwgb3B0aW9ucy5jb250ZXh0KTtcbiAgcmV0dXJuIHNjaGVtYVttZXRob2RdKHBhcmVudCAmJiBwYXJlbnRbcGFyZW50UGF0aF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBwYXJlbnQsXG4gICAgcGF0aFxuICB9KSk7XG59O1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ2VxdWFscycsICdpcyddKSBTY2hlbWEucHJvdG90eXBlW2FsaWFzXSA9IFNjaGVtYS5wcm90b3R5cGUub25lT2Y7XG5mb3IgKGNvbnN0IGFsaWFzIG9mIFsnbm90JywgJ25vcGUnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm5vdE9uZU9mO1xuXG5jb25zdCByZXR1cm5zVHJ1ZSA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBjcmVhdGUkOChzcGVjKSB7XG4gIHJldHVybiBuZXcgTWl4ZWRTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBNaXhlZFNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBzdXBlcih0eXBlb2Ygc3BlYyA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogc3BlY1xuICAgIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogcmV0dXJuc1RydWVcbiAgICB9LCBzcGVjKSk7XG4gIH1cbn1cbmNyZWF0ZSQ4LnByb3RvdHlwZSA9IE1peGVkU2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlJDcoKSB7XG4gIHJldHVybiBuZXcgQm9vbGVhblNjaGVtYSgpO1xufVxuY2xhc3MgQm9vbGVhblNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBCb29sZWFuKSB2ID0gdi52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguc3BlYy5jb2VyY2UgJiYgIWN0eC5pc1R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKC9eKHRydWV8MSkkL2kudGVzdChTdHJpbmcodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKC9eKGZhbHNlfDApJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpc1RydWUobWVzc2FnZSA9IGJvb2xlYW4uaXNWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdpcy12YWx1ZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0ZhbHNlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAnZmFsc2UnXG4gICAgICB9LFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWZhdWx0KGRlZikge1xuICAgIHJldHVybiBzdXBlci5kZWZhdWx0KGRlZik7XG4gIH1cbiAgZGVmaW5lZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmaW5lZChtc2cpO1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBzdXBlci5vcHRpb25hbCgpO1xuICB9XG4gIHJlcXVpcmVkKG1zZykge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtc2cpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci5udWxsYWJsZSgpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1zZykge1xuICAgIHJldHVybiBzdXBlci5ub25OdWxsYWJsZShtc2cpO1xuICB9XG4gIHN0cmlwKHYpIHtcbiAgICByZXR1cm4gc3VwZXIuc3RyaXAodik7XG4gIH1cbn1cbmNyZWF0ZSQ3LnByb3RvdHlwZSA9IEJvb2xlYW5TY2hlbWEucHJvdG90eXBlO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGZpbGUgZnJvbSB0aGUgZm9sbG93aW5nIHJlcG9zaXRvcnk6XG4gKiBEYXRlLnBhcnNlIHdpdGggcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQgZm9yIElTTyA4NjAxIDxodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9qcy1pc284NjAxPlxuICogTk9OLUNPTkZPUk1BTlQgRURJVElPTi5cbiAqIMKpIDIwMTEgQ29saW4gU25vdmVyIDxodHRwOi8vemV0YWZsZWV0LmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICovXG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gICAgICAgICAgICAgICAgMSBZWVlZICAgICAgICAgICAgICAgIDIgTU0gICAgICAgIDMgREQgICAgICAgICAgICAgIDQgSEggICAgIDUgbW0gICAgICAgIDYgc3MgICAgICAgICAgIDcgbXNlYyAgICAgICAgIDggWiA5IMKxICAgMTAgdHpISCAgICAxMSB0em1tXG5jb25zdCBpc29SZWcgPSAvXihcXGR7NH18WystXVxcZHs2fSkoPzotPyhcXGR7Mn0pKD86LT8oXFxkezJ9KSk/KT8oPzpbIFRdPyhcXGR7Mn0pOj8oXFxkezJ9KSg/Ojo/KFxcZHsyfSkoPzpbLC5dKFxcZHsxLH0pKT8pPyg/OihaKXwoWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlSXNvRGF0ZShkYXRlKSB7XG4gIGNvbnN0IHN0cnVjdCA9IHBhcnNlRGF0ZVN0cnVjdChkYXRlKTtcbiAgaWYgKCFzdHJ1Y3QpIHJldHVybiBEYXRlLnBhcnNlID8gRGF0ZS5wYXJzZShkYXRlKSA6IE51bWJlci5OYU47XG5cbiAgLy8gdGltZXN0YW1wcyB3aXRob3V0IHRpbWV6b25lIGlkZW50aWZpZXJzIHNob3VsZCBiZSBjb25zaWRlcmVkIGxvY2FsIHRpbWVcbiAgaWYgKHN0cnVjdC56ID09PSB1bmRlZmluZWQgJiYgc3RydWN0LnBsdXNNaW51cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN0cnVjdC55ZWFyLCBzdHJ1Y3QubW9udGgsIHN0cnVjdC5kYXksIHN0cnVjdC5ob3VyLCBzdHJ1Y3QubWludXRlLCBzdHJ1Y3Quc2Vjb25kLCBzdHJ1Y3QubWlsbGlzZWNvbmQpLnZhbHVlT2YoKTtcbiAgfVxuICBsZXQgdG90YWxNaW51dGVzT2Zmc2V0ID0gMDtcbiAgaWYgKHN0cnVjdC56ICE9PSAnWicgJiYgc3RydWN0LnBsdXNNaW51cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxNaW51dGVzT2Zmc2V0ID0gc3RydWN0LmhvdXJPZmZzZXQgKiA2MCArIHN0cnVjdC5taW51dGVPZmZzZXQ7XG4gICAgaWYgKHN0cnVjdC5wbHVzTWludXMgPT09ICcrJykgdG90YWxNaW51dGVzT2Zmc2V0ID0gMCAtIHRvdGFsTWludXRlc09mZnNldDtcbiAgfVxuICByZXR1cm4gRGF0ZS5VVEMoc3RydWN0LnllYXIsIHN0cnVjdC5tb250aCwgc3RydWN0LmRheSwgc3RydWN0LmhvdXIsIHN0cnVjdC5taW51dGUgKyB0b3RhbE1pbnV0ZXNPZmZzZXQsIHN0cnVjdC5zZWNvbmQsIHN0cnVjdC5taWxsaXNlY29uZCk7XG59XG5mdW5jdGlvbiBwYXJzZURhdGVTdHJ1Y3QoZGF0ZSkge1xuICB2YXIgX3JlZ2V4UmVzdWx0JDckbGVuZ3RoLCBfcmVnZXhSZXN1bHQkO1xuICBjb25zdCByZWdleFJlc3VsdCA9IGlzb1JlZy5leGVjKGRhdGUpO1xuICBpZiAoIXJlZ2V4UmVzdWx0KSByZXR1cm4gbnVsbDtcblxuICAvLyB1c2Ugb2YgdG9OdW1iZXIoKSBhdm9pZHMgTmFOIHRpbWVzdGFtcHMgY2F1c2VkIGJ5IOKAnHVuZGVmaW5lZOKAnVxuICAvLyB2YWx1ZXMgYmVpbmcgcGFzc2VkIHRvIERhdGUgY29uc3RydWN0b3JcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiB0b051bWJlcihyZWdleFJlc3VsdFsxXSksXG4gICAgbW9udGg6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzJdLCAxKSAtIDEsXG4gICAgZGF5OiB0b051bWJlcihyZWdleFJlc3VsdFszXSwgMSksXG4gICAgaG91cjogdG9OdW1iZXIocmVnZXhSZXN1bHRbNF0pLFxuICAgIG1pbnV0ZTogdG9OdW1iZXIocmVnZXhSZXN1bHRbNV0pLFxuICAgIHNlY29uZDogdG9OdW1iZXIocmVnZXhSZXN1bHRbNl0pLFxuICAgIG1pbGxpc2Vjb25kOiByZWdleFJlc3VsdFs3XSA/XG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN1Yi1zZWNvbmQgcHJlY2lzaW9uIGJleW9uZCBtaWxsaXNlY29uZHNcbiAgICB0b051bWJlcihyZWdleFJlc3VsdFs3XS5zdWJzdHJpbmcoMCwgMykpIDogMCxcbiAgICBwcmVjaXNpb246IChfcmVnZXhSZXN1bHQkNyRsZW5ndGggPSAoX3JlZ2V4UmVzdWx0JCA9IHJlZ2V4UmVzdWx0WzddKSA9PSBudWxsID8gdm9pZCAwIDogX3JlZ2V4UmVzdWx0JC5sZW5ndGgpICE9IG51bGwgPyBfcmVnZXhSZXN1bHQkNyRsZW5ndGggOiB1bmRlZmluZWQsXG4gICAgejogcmVnZXhSZXN1bHRbOF0gfHwgdW5kZWZpbmVkLFxuICAgIHBsdXNNaW51czogcmVnZXhSZXN1bHRbOV0gfHwgdW5kZWZpbmVkLFxuICAgIGhvdXJPZmZzZXQ6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzEwXSksXG4gICAgbWludXRlT2Zmc2V0OiB0b051bWJlcihyZWdleFJlc3VsdFsxMV0pXG4gIH07XG59XG5mdW5jdGlvbiB0b051bWJlcihzdHIsIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgcmV0dXJuIE51bWJlcihzdHIpIHx8IGRlZmF1bHRWYWx1ZTtcbn1cblxuLy8gVGFrZW4gZnJvbSBIVE1MIHNwZWM6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2lucHV0Lmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcbmxldCByRW1haWwgPVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbmxldCByVXJsID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuL14oKGh0dHBzP3xmdHApOik/XFwvXFwvKCgoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kL2k7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxubGV0IHJVVUlEID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xubGV0IHllYXJNb250aERheSA9ICdeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn0nO1xubGV0IGhvdXJNaW51dGVTZWNvbmQgPSAnXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0nO1xubGV0IHpPck9mZnNldCA9ICcoKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJztcbmxldCBySXNvRGF0ZVRpbWUgPSBuZXcgUmVnRXhwKGAke3llYXJNb250aERheX1UJHtob3VyTWludXRlU2Vjb25kfShcXFxcLlxcXFxkKyk/JHt6T3JPZmZzZXR9JGApO1xubGV0IGlzVHJpbW1lZCA9IHZhbHVlID0+IGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpO1xubGV0IG9ialN0cmluZ1RhZyA9IHt9LnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBjcmVhdGUkNigpIHtcbiAgcmV0dXJuIG5ldyBTdHJpbmdTY2hlbWEoKTtcbn1cbmNsYXNzIFN0cmluZ1NjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UgfHwgY3R4LmlzVHlwZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvLyBkb24ndCBldmVyIGNvbnZlcnQgYXJyYXlzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjb25zdCBzdHJWYWx1ZSA9IHZhbHVlICE9IG51bGwgJiYgdmFsdWUudG9TdHJpbmcgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG5cbiAgICAgICAgLy8gbm8gb25lIHdhbnRzIHBsYWluIG9iamVjdHMgY29udmVydGVkIHRvIFtPYmplY3Qgb2JqZWN0XVxuICAgICAgICBpZiAoc3RyVmFsdWUgPT09IG9ialN0cmluZ1RhZykgcmV0dXJuIHZhbHVlO1xuICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXF1aXJlZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnJlcXVpcmVkKG1lc3NhZ2UpLndpdGhNdXRhdGlvbihzY2hlbWEgPT4gc2NoZW1hLnRlc3Qoe1xuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBtaXhlZC5yZXF1aXJlZCxcbiAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gISF2YWx1ZS5sZW5ndGhcbiAgICB9KSk7XG4gIH1cbiAgbm90UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLm5vdFJlcXVpcmVkKCkud2l0aE11dGF0aW9uKHNjaGVtYSA9PiB7XG4gICAgICBzY2hlbWEudGVzdHMgPSBzY2hlbWEudGVzdHMuZmlsdGVyKHQgPT4gdC5PUFRJT05TLm5hbWUgIT09ICdyZXF1aXJlZCcpO1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuZ3RoLCBtZXNzYWdlID0gc3RyaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IHRoaXMucmVzb2x2ZShsZW5ndGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UgPSBzdHJpbmcubWluKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gc3RyaW5nLm1heCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF0Y2hlcyhyZWdleCwgb3B0aW9ucykge1xuICAgIGxldCBleGNsdWRlRW1wdHlTdHJpbmcgPSBmYWxzZTtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAoe1xuICAgICAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZyA9IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgbmFtZVxuICAgICAgICB9ID0gb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiBuYW1lIHx8ICdtYXRjaGVzJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgc3RyaW5nLm1hdGNoZXMsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcmVnZXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gdmFsdWUgPT09ICcnICYmIGV4Y2x1ZGVFbXB0eVN0cmluZyB8fCB2YWx1ZS5zZWFyY2gocmVnZXgpICE9PSAtMVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKG1lc3NhZ2UgPSBzdHJpbmcuZW1haWwpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHJFbWFpbCwge1xuICAgICAgbmFtZTogJ2VtYWlsJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICB1cmwobWVzc2FnZSA9IHN0cmluZy51cmwpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHJVcmwsIHtcbiAgICAgIG5hbWU6ICd1cmwnLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHV1aWQobWVzc2FnZSA9IHN0cmluZy51dWlkKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVVVJRCwge1xuICAgICAgbmFtZTogJ3V1aWQnLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICBsZXQgYWxsb3dPZmZzZXQ7XG4gICAgbGV0IHByZWNpc2lvbjtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAoe1xuICAgICAgICAgIG1lc3NhZ2UgPSAnJyxcbiAgICAgICAgICBhbGxvd09mZnNldCA9IGZhbHNlLFxuICAgICAgICAgIHByZWNpc2lvbiA9IHVuZGVmaW5lZFxuICAgICAgICB9ID0gb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhySXNvRGF0ZVRpbWUsIHtcbiAgICAgIG5hbWU6ICdkYXRldGltZScsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxuICAgIH0pLnRlc3Qoe1xuICAgICAgbmFtZTogJ2RhdGV0aW1lX29mZnNldCcsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZV9vZmZzZXQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgYWxsb3dPZmZzZXRcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlIHx8IGFsbG93T2Zmc2V0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gcGFyc2VEYXRlU3RydWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFzdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICEhc3RydWN0Lno7XG4gICAgICB9XG4gICAgfSkudGVzdCh7XG4gICAgICBuYW1lOiAnZGF0ZXRpbWVfcHJlY2lzaW9uJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgc3RyaW5nLmRhdGV0aW1lX3ByZWNpc2lvbixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwcmVjaXNpb25cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHByZWNpc2lvbiA9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBwYXJzZURhdGVTdHJ1Y3QodmFsdWUpO1xuICAgICAgICBpZiAoIXN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RydWN0LnByZWNpc2lvbiA9PT0gcHJlY2lzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8tLSB0cmFuc2Zvcm1zIC0tXG4gIGVuc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0KCcnKS50cmFuc2Zvcm0odmFsID0+IHZhbCA9PT0gbnVsbCA/ICcnIDogdmFsKTtcbiAgfVxuICB0cmltKG1lc3NhZ2UgPSBzdHJpbmcudHJpbSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWwgPT4gdmFsICE9IG51bGwgPyB2YWwudHJpbSgpIDogdmFsKS50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHJpbScsXG4gICAgICB0ZXN0OiBpc1RyaW1tZWRcbiAgICB9KTtcbiAgfVxuICBsb3dlcmNhc2UobWVzc2FnZSA9IHN0cmluZy5sb3dlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICB9KTtcbiAgfVxuICB1cHBlcmNhc2UobWVzc2FnZSA9IHN0cmluZy51cHBlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICB9KTtcbiAgfVxufVxuY3JlYXRlJDYucHJvdG90eXBlID0gU3RyaW5nU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIFN0cmluZyBJbnRlcmZhY2VzXG4vL1xuXG5sZXQgaXNOYU4kMSA9IHZhbHVlID0+IHZhbHVlICE9ICt2YWx1ZTtcbmZ1bmN0aW9uIGNyZWF0ZSQ1KCkge1xuICByZXR1cm4gbmV3IE51bWJlclNjaGVtYSgpO1xufVxuY2xhc3MgTnVtYmVyU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4kMSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZWQucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgICBpZiAocGFyc2VkID09PSAnJykgcmV0dXJuIE5hTjtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgcGFyc2VGbG9hdCB0byBhdm9pZCBwb3NpdGl2ZXMgb24gYWxwaGEtbnVtZXJpYyBzdHJpbmdzXG4gICAgICAgICAgcGFyc2VkID0gK3BhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG51bGwgLT4gTmFOIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXG4gICAgICAgIC8vIG51bGxhYmlsaXR5IGNoZWNrIHZzIFR5cGVFcnJvcnNcbiAgICAgICAgaWYgKGN0eC5pc1R5cGUocGFyc2VkKSB8fCBwYXJzZWQgPT09IG51bGwpIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gbnVtYmVyLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gbnVtYmVyLm1heCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXNzVGhhbihsZXNzLCBtZXNzYWdlID0gbnVtYmVyLmxlc3NUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVzc1xuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IHRoaXMucmVzb2x2ZShsZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtb3JlVGhhbihtb3JlLCBtZXNzYWdlID0gbnVtYmVyLm1vcmVUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9yZVxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+IHRoaXMucmVzb2x2ZShtb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwb3NpdGl2ZShtc2cgPSBudW1iZXIucG9zaXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5tb3JlVGhhbigwLCBtc2cpO1xuICB9XG4gIG5lZ2F0aXZlKG1zZyA9IG51bWJlci5uZWdhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKDAsIG1zZyk7XG4gIH1cbiAgaW50ZWdlcihtZXNzYWdlID0gbnVtYmVyLmludGVnZXIpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdpbnRlZ2VyJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsID0+IE51bWJlci5pc0ludGVnZXIodmFsKVxuICAgIH0pO1xuICB9XG4gIHRydW5jYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gdmFsdWUgfCAwIDogdmFsdWUpO1xuICB9XG4gIHJvdW5kKG1ldGhvZCkge1xuICAgIHZhciBfbWV0aG9kO1xuICAgIGxldCBhdmFpbCA9IFsnY2VpbCcsICdmbG9vcicsICdyb3VuZCcsICd0cnVuYyddO1xuICAgIG1ldGhvZCA9ICgoX21ldGhvZCA9IG1ldGhvZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZXRob2QudG9Mb3dlckNhc2UoKSkgfHwgJ3JvdW5kJztcblxuICAgIC8vIHRoaXMgZXhpc3RzIGZvciBzeW1lbXRyeSB3aXRoIHRoZSBuZXcgTWF0aC50cnVuY1xuICAgIGlmIChtZXRob2QgPT09ICd0cnVuYycpIHJldHVybiB0aGlzLnRydW5jYXRlKCk7XG4gICAgaWYgKGF2YWlsLmluZGV4T2YobWV0aG9kLnRvTG93ZXJDYXNlKCkpID09PSAtMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignT25seSB2YWxpZCBvcHRpb25zIGZvciByb3VuZCgpIGFyZTogJyArIGF2YWlsLmpvaW4oJywgJykpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gTWF0aFttZXRob2RdKHZhbHVlKSA6IHZhbHVlKTtcbiAgfVxufVxuY3JlYXRlJDUucHJvdG90eXBlID0gTnVtYmVyU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIE51bWJlciBJbnRlcmZhY2VzXG4vL1xuXG5sZXQgaW52YWxpZERhdGUgPSBuZXcgRGF0ZSgnJyk7XG5sZXQgaXNEYXRlID0gb2JqID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG5mdW5jdGlvbiBjcmVhdGUkNCgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlU2NoZW1hKCk7XG59XG5jbGFzcyBEYXRlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgY2hlY2sodikge1xuICAgICAgICByZXR1cm4gaXNEYXRlKHYpICYmICFpc05hTih2LmdldFRpbWUoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgLy8gbnVsbCAtPiBJbnZhbGlkRGF0ZSBpc24ndCB1c2VmdWw7IHRyZWF0IGFsbCBudWxscyBhcyBudWxsIGFuZCBsZXQgaXQgZmFpbCBvblxuICAgICAgICAvLyBudWxsYWJpbGl0eSBjaGVjayB2cyBUeXBlRXJyb3JzXG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJc29EYXRlKHZhbHVlKTtcblxuICAgICAgICAvLyAwIGlzIGEgdmFsaWQgdGltZXN0YW1wIGVxdWl2YWxlbnQgdG8gMTk3MC0wMS0wMVQwMDowMDowMFoodW5peCBlcG9jaCkgb3IgYmVmb3JlLlxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSA/IG5ldyBEYXRlKHZhbHVlKSA6IERhdGVTY2hlbWEuSU5WQUxJRF9EQVRFO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcHJlcGFyZVBhcmFtKHJlZiwgbmFtZSkge1xuICAgIGxldCBwYXJhbTtcbiAgICBpZiAoIVJlZmVyZW5jZS5pc1JlZihyZWYpKSB7XG4gICAgICBsZXQgY2FzdCA9IHRoaXMuY2FzdChyZWYpO1xuICAgICAgaWYgKCF0aGlzLl90eXBlQ2hlY2soY2FzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcYCR7bmFtZX1cXGAgbXVzdCBiZSBhIERhdGUgb3IgYSB2YWx1ZSB0aGF0IGNhbiBiZSBcXGBjYXN0KClcXGAgdG8gYSBEYXRlYCk7XG4gICAgICBwYXJhbSA9IGNhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtID0gcmVmO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IGRhdGUubWluKSB7XG4gICAgbGV0IGxpbWl0ID0gdGhpcy5wcmVwYXJlUGFyYW0obWluLCAnbWluJyk7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IHRoaXMucmVzb2x2ZShsaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IGRhdGUubWF4KSB7XG4gICAgbGV0IGxpbWl0ID0gdGhpcy5wcmVwYXJlUGFyYW0obWF4LCAnbWF4Jyk7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMucmVzb2x2ZShsaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbkRhdGVTY2hlbWEuSU5WQUxJRF9EQVRFID0gaW52YWxpZERhdGU7XG5jcmVhdGUkNC5wcm90b3R5cGUgPSBEYXRlU2NoZW1hLnByb3RvdHlwZTtcbmNyZWF0ZSQ0LklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5mdW5jdGlvbiBzb3J0RmllbGRzKGZpZWxkcywgZXhjbHVkZWRFZGdlcyA9IFtdKSB7XG4gIGxldCBlZGdlcyA9IFtdO1xuICBsZXQgbm9kZXMgPSBuZXcgU2V0KCk7XG4gIGxldCBleGNsdWRlcyA9IG5ldyBTZXQoZXhjbHVkZWRFZGdlcy5tYXAoKFthLCBiXSkgPT4gYCR7YX0tJHtifWApKTtcbiAgZnVuY3Rpb24gYWRkTm9kZShkZXBQYXRoLCBrZXkpIHtcbiAgICBsZXQgbm9kZSA9IHNwbGl0KGRlcFBhdGgpWzBdO1xuICAgIG5vZGVzLmFkZChub2RlKTtcbiAgICBpZiAoIWV4Y2x1ZGVzLmhhcyhgJHtrZXl9LSR7bm9kZX1gKSkgZWRnZXMucHVzaChba2V5LCBub2RlXSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgIGxldCB2YWx1ZSA9IGZpZWxkc1trZXldO1xuICAgIG5vZGVzLmFkZChrZXkpO1xuICAgIGlmIChSZWZlcmVuY2UuaXNSZWYodmFsdWUpICYmIHZhbHVlLmlzU2libGluZykgYWRkTm9kZSh2YWx1ZS5wYXRoLCBrZXkpO2Vsc2UgaWYgKGlzU2NoZW1hKHZhbHVlKSAmJiAnZGVwcycgaW4gdmFsdWUpIHZhbHVlLmRlcHMuZm9yRWFjaChwYXRoID0+IGFkZE5vZGUocGF0aCwga2V5KSk7XG4gIH1cbiAgcmV0dXJuIHRvcG9zb3J0LmFycmF5KEFycmF5LmZyb20obm9kZXMpLCBlZGdlcykucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBlcnIpIHtcbiAgbGV0IGlkeCA9IEluZmluaXR5O1xuICBhcnIuc29tZSgoa2V5LCBpaSkgPT4ge1xuICAgIHZhciBfZXJyJHBhdGg7XG4gICAgaWYgKChfZXJyJHBhdGggPSBlcnIucGF0aCkgIT0gbnVsbCAmJiBfZXJyJHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgaWR4ID0gaWk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gc29ydEJ5S2V5T3JkZXIoa2V5cykge1xuICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICByZXR1cm4gZmluZEluZGV4KGtleXMsIGEpIC0gZmluZEluZGV4KGtleXMsIGIpO1xuICB9O1xufVxuXG5jb25zdCBwYXJzZUpzb24gPSAodmFsdWUsIF8sIGN0eCkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBsZXQgcGFyc2VkID0gdmFsdWU7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8qICovXG4gIH1cbiAgcmV0dXJuIGN0eC5pc1R5cGUocGFyc2VkKSA/IHBhcnNlZCA6IHZhbHVlO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gZGVlcFBhcnRpYWwoc2NoZW1hKSB7XG4gIGlmICgnZmllbGRzJyBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBmaWVsZFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgIHBhcnRpYWxba2V5XSA9IGRlZXBQYXJ0aWFsKGZpZWxkU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5zZXRGaWVsZHMocGFydGlhbCk7XG4gIH1cbiAgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgbmV4dEFycmF5ID0gc2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgaWYgKG5leHRBcnJheS5pbm5lclR5cGUpIG5leHRBcnJheS5pbm5lclR5cGUgPSBkZWVwUGFydGlhbChuZXh0QXJyYXkuaW5uZXJUeXBlKTtcbiAgICByZXR1cm4gbmV4dEFycmF5O1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKS5jbG9uZSh7XG4gICAgICB0eXBlczogc2NoZW1hLnNwZWMudHlwZXMubWFwKGRlZXBQYXJ0aWFsKVxuICAgIH0pO1xuICB9XG4gIGlmICgnb3B0aW9uYWwnIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuY29uc3QgZGVlcEhhcyA9IChvYmosIHApID0+IHtcbiAgY29uc3QgcGF0aCA9IFsuLi5ub3JtYWxpemVQYXRoKHApXTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSByZXR1cm4gcGF0aFswXSBpbiBvYmo7XG4gIGxldCBsYXN0ID0gcGF0aC5wb3AoKTtcbiAgbGV0IHBhcmVudCA9IGdldHRlcihqb2luKHBhdGgpLCB0cnVlKShvYmopO1xuICByZXR1cm4gISEocGFyZW50ICYmIGxhc3QgaW4gcGFyZW50KTtcbn07XG5sZXQgaXNPYmplY3QgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gdW5rbm93bihjdHgsIHZhbHVlKSB7XG4gIGxldCBrbm93biA9IE9iamVjdC5rZXlzKGN0eC5maWVsZHMpO1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihrZXkgPT4ga25vd24uaW5kZXhPZihrZXkpID09PSAtMSk7XG59XG5jb25zdCBkZWZhdWx0U29ydCA9IHNvcnRCeUtleU9yZGVyKFtdKTtcbmZ1bmN0aW9uIGNyZWF0ZSQzKHNwZWMpIHtcbiAgcmV0dXJuIG5ldyBPYmplY3RTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBPYmplY3RTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZpZWxkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fc29ydEVycm9ycyA9IGRlZmF1bHRTb3J0O1xuICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgdGhpcy5fZXhjbHVkZWRFZGdlcyA9IFtdO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgIHRoaXMuc2hhcGUoc3BlYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2Nhc3QoX3ZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX29wdGlvbnMkc3RyaXBVbmtub3duO1xuICAgIGxldCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAvL3Nob3VsZCBpZ25vcmUgbnVsbHMgaGVyZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIGxldCBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICBsZXQgc3RyaXAgPSAoX29wdGlvbnMkc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd24pICE9IG51bGwgPyBfb3B0aW9ucyRzdHJpcFVua25vd24gOiB0aGlzLnNwZWMubm9Vbmtub3duO1xuICAgIGxldCBwcm9wcyA9IFtdLmNvbmNhdCh0aGlzLl9ub2RlcywgT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcih2ID0+ICF0aGlzLl9ub2Rlcy5pbmNsdWRlcyh2KSkpO1xuICAgIGxldCBpbnRlcm1lZGlhdGVWYWx1ZSA9IHt9OyAvLyBpcyBmaWxsZWQgZHVyaW5nIHRoZSB0cmFuc2Zvcm0gYmVsb3dcbiAgICBsZXQgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiBpbnRlcm1lZGlhdGVWYWx1ZSxcbiAgICAgIF9fdmFsaWRhdGluZzogb3B0aW9ucy5fX3ZhbGlkYXRpbmcgfHwgZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF07XG4gICAgICBsZXQgZXhpc3RzID0gKHByb3AgaW4gdmFsdWUpO1xuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlO1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IHZhbHVlW3Byb3BdO1xuXG4gICAgICAgIC8vIHNhZmUgdG8gbXV0YXRlIHNpbmNlIHRoaXMgaXMgZmlyZWQgaW4gc2VxdWVuY2VcbiAgICAgICAgaW5uZXJPcHRpb25zLnBhdGggPSAob3B0aW9ucy5wYXRoID8gYCR7b3B0aW9ucy5wYXRofS5gIDogJycpICsgcHJvcDtcbiAgICAgICAgZmllbGQgPSBmaWVsZC5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgcGFyZW50OiBpbnRlcm1lZGlhdGVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpZWxkU3BlYyA9IGZpZWxkIGluc3RhbmNlb2YgU2NoZW1hID8gZmllbGQuc3BlYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmljdCA9IGZpZWxkU3BlYyA9PSBudWxsID8gdm9pZCAwIDogZmllbGRTcGVjLnN0cmljdDtcbiAgICAgICAgaWYgKGZpZWxkU3BlYyAhPSBudWxsICYmIGZpZWxkU3BlYy5zdHJpcCkge1xuICAgICAgICAgIGlzQ2hhbmdlZCA9IGlzQ2hhbmdlZCB8fCBwcm9wIGluIHZhbHVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWUgPSAhb3B0aW9ucy5fX3ZhbGlkYXRpbmcgfHwgIXN0cmljdCA/XG4gICAgICAgIC8vIFRPRE86IHVzZSBfY2FzdCwgdGhpcyBpcyBkb3VibGUgcmVzb2x2aW5nXG4gICAgICAgIGZpZWxkLmNhc3QodmFsdWVbcHJvcF0sIGlubmVyT3B0aW9ucykgOiB2YWx1ZVtwcm9wXTtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlW3Byb3BdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdHMgJiYgIXN0cmlwKSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlW3Byb3BdID0gdmFsdWVbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RzICE9PSBwcm9wIGluIGludGVybWVkaWF0ZVZhbHVlIHx8IGludGVybWVkaWF0ZVZhbHVlW3Byb3BdICE9PSB2YWx1ZVtwcm9wXSkge1xuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gaW50ZXJtZWRpYXRlVmFsdWUgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIGZyb20gPSBbXSxcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBfdmFsdWUsXG4gICAgICByZWN1cnNpdmUgPSB0aGlzLnNwZWMucmVjdXJzaXZlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucy5mcm9tID0gW3tcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHZhbHVlOiBvcmlnaW5hbFZhbHVlXG4gICAgfSwgLi4uZnJvbV07XG4gICAgLy8gdGhpcyBmbGFnIGlzIG5lZWRlZCBmb3IgaGFuZGxpbmcgYHN0cmljdGAgY29ycmVjdGx5IGluIHRoZSBjb250ZXh0IG9mXG4gICAgLy8gdmFsaWRhdGlvbiB2cyBqdXN0IGNhc3RpbmcuIGUuZyBzdHJpY3QoKSBvbiBhIGZpZWxkIGlzIG9ubHkgdXNlZCB3aGVuIHZhbGlkYXRpbmdcbiAgICBvcHRpb25zLl9fdmFsaWRhdGluZyA9IHRydWU7XG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxWYWx1ZTtcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKG9iamVjdEVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dChvYmplY3RFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWUgfHwgdmFsdWU7XG4gICAgICBsZXQgdGVzdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl9ub2Rlcykge1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgICBpZiAoIWZpZWxkIHx8IFJlZmVyZW5jZS5pc1JlZihmaWVsZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXN0cy5wdXNoKGZpZWxkLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IG9yaWdpbmFsVmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHRlc3RzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGZpZWxkRXJyb3JzID0+IHtcbiAgICAgICAgbmV4dChmaWVsZEVycm9ycy5zb3J0KHRoaXMuX3NvcnRFcnJvcnMpLmNvbmNhdChvYmplY3RFcnJvcnMpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IHN1cGVyLmNsb25lKHNwZWMpO1xuICAgIG5leHQuZmllbGRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHMpO1xuICAgIG5leHQuX25vZGVzID0gdGhpcy5fbm9kZXM7XG4gICAgbmV4dC5fZXhjbHVkZWRFZGdlcyA9IHRoaXMuX2V4Y2x1ZGVkRWRnZXM7XG4gICAgbmV4dC5fc29ydEVycm9ycyA9IHRoaXMuX3NvcnRFcnJvcnM7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XG4gICAgbGV0IG5leHRGaWVsZHMgPSBuZXh0LmZpZWxkcztcbiAgICBmb3IgKGxldCBbZmllbGQsIHNjaGVtYU9yUmVmXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG5leHRGaWVsZHNbZmllbGRdO1xuICAgICAgbmV4dEZpZWxkc1tmaWVsZF0gPSB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IHNjaGVtYU9yUmVmIDogdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dC53aXRoTXV0YXRpb24ocyA9PlxuICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xuICAgIHMuc2V0RmllbGRzKG5leHRGaWVsZHMsIFsuLi50aGlzLl9leGNsdWRlZEVkZ2VzLCAuLi5zY2hlbWEuX2V4Y2x1ZGVkRWRnZXNdKSk7XG4gIH1cbiAgX2dldERlZmF1bHQob3B0aW9ucykge1xuICAgIGlmICgnZGVmYXVsdCcgaW4gdGhpcy5zcGVjKSB7XG4gICAgICByZXR1cm4gc3VwZXIuX2dldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBzZXQgaW52ZW50IG9uZVxuICAgIGlmICghdGhpcy5fbm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZGZ0ID0ge307XG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRmdFtrZXldID0gZmllbGQgJiYgJ2dldERlZmF1bHQnIGluIGZpZWxkID8gZmllbGQuZ2V0RGVmYXVsdChpbm5lck9wdGlvbnMpIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHJldHVybiBkZnQ7XG4gIH1cbiAgc2V0RmllbGRzKHNoYXBlLCBleGNsdWRlZEVkZ2VzKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5maWVsZHMgPSBzaGFwZTtcbiAgICBuZXh0Ll9ub2RlcyA9IHNvcnRGaWVsZHMoc2hhcGUsIGV4Y2x1ZGVkRWRnZXMpO1xuICAgIG5leHQuX3NvcnRFcnJvcnMgPSBzb3J0QnlLZXlPcmRlcihPYmplY3Qua2V5cyhzaGFwZSkpO1xuICAgIC8vIFhYWDogdGhpcyBjYXJyaWVzIG92ZXIgZWRnZXMgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50XG4gICAgaWYgKGV4Y2x1ZGVkRWRnZXMpIG5leHQuX2V4Y2x1ZGVkRWRnZXMgPSBleGNsdWRlZEVkZ2VzO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHNoYXBlKGFkZGl0aW9ucywgZXhjbHVkZXMgPSBbXSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4ge1xuICAgICAgbGV0IGVkZ2VzID0gbmV4dC5fZXhjbHVkZWRFZGdlcztcbiAgICAgIGlmIChleGNsdWRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4Y2x1ZGVzWzBdKSkgZXhjbHVkZXMgPSBbZXhjbHVkZXNdO1xuICAgICAgICBlZGdlcyA9IFsuLi5uZXh0Ll9leGNsdWRlZEVkZ2VzLCAuLi5leGNsdWRlc107XG4gICAgICB9XG5cbiAgICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xuICAgICAgcmV0dXJuIG5leHQuc2V0RmllbGRzKE9iamVjdC5hc3NpZ24obmV4dC5maWVsZHMsIGFkZGl0aW9ucyksIGVkZ2VzKTtcbiAgICB9KTtcbiAgfVxuICBwYXJ0aWFsKCkge1xuICAgIGNvbnN0IHBhcnRpYWwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBwYXJ0aWFsW2tleV0gPSAnb3B0aW9uYWwnIGluIHNjaGVtYSAmJiBzY2hlbWEub3B0aW9uYWwgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHNjaGVtYS5vcHRpb25hbCgpIDogc2NoZW1hO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGFydGlhbCk7XG4gIH1cbiAgZGVlcFBhcnRpYWwoKSB7XG4gICAgY29uc3QgbmV4dCA9IGRlZXBQYXJ0aWFsKHRoaXMpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHBpY2soa2V5cykge1xuICAgIGNvbnN0IHBpY2tlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICh0aGlzLmZpZWxkc1trZXldKSBwaWNrZWRba2V5XSA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNldEZpZWxkcyhwaWNrZWQsIHRoaXMuX2V4Y2x1ZGVkRWRnZXMuZmlsdGVyKChbYSwgYl0pID0+IGtleXMuaW5jbHVkZXMoYSkgJiYga2V5cy5pbmNsdWRlcyhiKSkpO1xuICB9XG4gIG9taXQoa2V5cykge1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSkge1xuICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICByZW1haW5pbmcucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5waWNrKHJlbWFpbmluZyk7XG4gIH1cbiAgZnJvbShmcm9tLCB0bywgYWxpYXMpIHtcbiAgICBsZXQgZnJvbUdldHRlciA9IGdldHRlcihmcm9tLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuICAgICAgbGV0IG5ld09iaiA9IG9iajtcbiAgICAgIGlmIChkZWVwSGFzKG9iaiwgZnJvbSkpIHtcbiAgICAgICAgbmV3T2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgaWYgKCFhbGlhcykgZGVsZXRlIG5ld09ialtmcm9tXTtcbiAgICAgICAgbmV3T2JqW3RvXSA9IGZyb21HZXR0ZXIob2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSk7XG4gIH1cblxuICAvKiogUGFyc2UgYW4gaW5wdXQgSlNPTiBzdHJpbmcgdG8gYW4gb2JqZWN0ICovXG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XG4gIH1cblxuICAvKipcbiAgICogU2ltaWxhciB0byBgbm9Vbmtub3duYCBidXQgb25seSB2YWxpZGF0ZXMgdGhhdCBhbiBvYmplY3QgaXMgdGhlIHJpZ2h0IHNoYXBlIHdpdGhvdXQgc3RyaXBwaW5nIHRoZSB1bmtub3duIGtleXNcbiAgICovXG4gIGV4YWN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdleGFjdCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IG9iamVjdC5leGFjdCxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHVua25vd24odGhpcy5zY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHVua25vd25LZXlzLmpvaW4oJywgJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0cmlwVW5rbm93bigpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XG4gICAgICBub1Vua25vd246IHRydWVcbiAgICB9KTtcbiAgfVxuICBub1Vua25vd24obm9BbGxvdyA9IHRydWUsIG1lc3NhZ2UgPSBvYmplY3Qubm9Vbmtub3duKSB7XG4gICAgaWYgKHR5cGVvZiBub0FsbG93ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIG1lc3NhZ2UgPSBub0FsbG93O1xuICAgICAgbm9BbGxvdyA9IHRydWU7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdub1Vua25vd24nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHVua25vd24odGhpcy5zY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICFub0FsbG93IHx8IHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHVua25vd246IHVua25vd25LZXlzLmpvaW4oJywgJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5leHQuc3BlYy5ub1Vua25vd24gPSBub0FsbG93O1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHVua25vd24oYWxsb3cgPSB0cnVlLCBtZXNzYWdlID0gb2JqZWN0Lm5vVW5rbm93bikge1xuICAgIHJldHVybiB0aGlzLm5vVW5rbm93bighYWxsb3csIG1lc3NhZ2UpO1xuICB9XG4gIHRyYW5zZm9ybUtleXMoZm4pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSByZXN1bHRbZm4oa2V5KV0gPSBvYmpba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgY2FtZWxDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoY2FtZWxDYXNlKTtcbiAgfVxuICBzbmFrZUNhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhzbmFrZUNhc2UpO1xuICB9XG4gIGNvbnN0YW50Q2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKGtleSA9PiBzbmFrZUNhc2Uoa2V5KS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgYmFzZS5maWVsZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhuZXh0LmZpZWxkcykpIHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zMjtcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zMiA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zMi52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYXNlLmZpZWxkc1trZXldID0gdmFsdWUuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQzLnByb3RvdHlwZSA9IE9iamVjdFNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZSQyKHR5cGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheVNjaGVtYSh0eXBlKTtcbn1cbmNsYXNzIEFycmF5U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIHR5cGVzOiB0eXBlXG4gICAgICB9LFxuICAgICAgY2hlY2sodikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGB1bmRlZmluZWRgIHNwZWNpZmljYWxseSBtZWFucyB1bmluaXRpYWxpemVkLCBhcyBvcHBvc2VkIHRvIFwibm8gc3VidHlwZVwiXG4gICAgdGhpcy5pbm5lclR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbm5lclR5cGUgPSB0eXBlO1xuICB9XG4gIF9jYXN0KF92YWx1ZSwgX29wdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgX29wdHMpO1xuXG4gICAgLy8gc2hvdWxkIGlnbm9yZSBudWxscyBoZXJlXG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpIHx8ICF0aGlzLmlubmVyVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgY2FzdEFycmF5ID0gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RFbGVtZW50ID0gdGhpcy5pbm5lclR5cGUuY2FzdCh2LCBPYmplY3QuYXNzaWduKHt9LCBfb3B0cywge1xuICAgICAgICBwYXRoOiBgJHtfb3B0cy5wYXRoIHx8ICcnfVske2lkeH1dYFxuICAgICAgfSkpO1xuICAgICAgaWYgKGNhc3RFbGVtZW50ICE9PSB2KSB7XG4gICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICB2YXIgX29wdGlvbnMkcmVjdXJzaXZlO1xuICAgIC8vIGxldCBzeW5jID0gb3B0aW9ucy5zeW5jO1xuICAgIC8vIGxldCBwYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgIGxldCBpbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICAvLyBsZXQgZW5kRWFybHkgPSBvcHRpb25zLmFib3J0RWFybHkgPz8gdGhpcy5zcGVjLmFib3J0RWFybHk7XG4gICAgbGV0IHJlY3Vyc2l2ZSA9IChfb3B0aW9ucyRyZWN1cnNpdmUgPSBvcHRpb25zLnJlY3Vyc2l2ZSkgIT0gbnVsbCA/IF9vcHRpb25zJHJlY3Vyc2l2ZSA6IHRoaXMuc3BlYy5yZWN1cnNpdmU7XG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlICE9IG51bGwgPyBvcHRpb25zLm9yaWdpbmFsVmFsdWUgOiBfdmFsdWU7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsIChhcnJheUVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyO1xuICAgICAgaWYgKCFyZWN1cnNpdmUgfHwgIWlubmVyVHlwZSB8fCAhdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgICBuZXh0KGFycmF5RXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gIzk1MCBFbnN1cmUgdGhhdCBzcGFyc2UgYXJyYXkgZW1wdHkgc2xvdHMgYXJlIHZhbGlkYXRlZFxuICAgICAgbGV0IHRlc3RzID0gbmV3IEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHU7XG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGlubmVyVHlwZS5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUgOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRlc3RzLFxuICAgICAgICBvcmlnaW5hbFZhbHVlOiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgOiBfdmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBpbm5lclR5cGVFcnJvcnMgPT4gbmV4dChpbm5lclR5cGVFcnJvcnMuY29uY2F0KGFycmF5RXJyb3JzKSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IHN1cGVyLmNsb25lKHNwZWMpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xuICBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShwYXJzZUpzb24pO1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBsZXQgbmV4dCA9IHN1cGVyLmNvbmNhdChzY2hlbWEpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgICBuZXh0LmlubmVyVHlwZSA9IG5leHQuaW5uZXJUeXBlID9cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTGF6eSBkb2Vzbid0IGhhdmUgY29uY2F0IGFuZCB3aWxsIGJyZWFrXG4gICAgICBuZXh0LmlubmVyVHlwZS5jb25jYXQoc2NoZW1hLmlubmVyVHlwZSkgOiBzY2hlbWEuaW5uZXJUeXBlO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9mKHNjaGVtYSkge1xuICAgIC8vIEZJWE1FOiB0aGlzIHNob3VsZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYXJyYXkgd2l0aG91dCB0aGUgZGVmYXVsdCB0byBiZVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFycmF5Lm9mKClgIHN1Yi1zY2hlbWEgbXVzdCBiZSBhIHZhbGlkIHl1cCBzY2hlbWEgbm90OiAnICsgcHJpbnRWYWx1ZShzY2hlbWEpKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHNjaGVtYTtcbiAgICBuZXh0LnNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0LnNwZWMsIHtcbiAgICAgIHR5cGVzOiBzY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBsZW5ndGgobGVuZ3RoLCBtZXNzYWdlID0gYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gdGhpcy5yZXNvbHZlKGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGFycmF5Lm1pbjtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgLy8gRklYTUUodHMpOiBBcnJheTx0eXBlb2YgVD5cbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgYXJyYXkubWF4O1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZW5zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHQoKCkgPT4gW10pLnRyYW5zZm9ybSgodmFsLCBvcmlnaW5hbCkgPT4ge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gYG51bGxgIGZvciBudWxsYWJsZSBzY2hlbWFcbiAgICAgIGlmICh0aGlzLl90eXBlQ2hlY2sodmFsKSkgcmV0dXJuIHZhbDtcbiAgICAgIHJldHVybiBvcmlnaW5hbCA9PSBudWxsID8gW10gOiBbXS5jb25jYXQob3JpZ2luYWwpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBhY3QocmVqZWN0b3IpIHtcbiAgICBsZXQgcmVqZWN0ID0gIXJlamVjdG9yID8gdiA9PiAhIXYgOiAodiwgaSwgYSkgPT4gIXJlamVjdG9yKHYsIGksIGEpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZXMgPT4gdmFsdWVzICE9IG51bGwgPyB2YWx1ZXMuZmlsdGVyKHJlamVjdCkgOiB2YWx1ZXMpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IGJhc2UgPSBzdXBlci5kZXNjcmliZShvcHRpb25zKTtcbiAgICBpZiAobmV4dC5pbm5lclR5cGUpIHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlWzBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmFzZS5pbm5lclR5cGUgPSBuZXh0LmlubmVyVHlwZS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufVxuY3JlYXRlJDIucHJvdG90eXBlID0gQXJyYXlTY2hlbWEucHJvdG90eXBlO1xuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBjcmVhdGUkMShzY2hlbWFzKSB7XG4gIHJldHVybiBuZXcgVHVwbGVTY2hlbWEoc2NoZW1hcyk7XG59XG5jbGFzcyBUdXBsZVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNjaGVtYXMpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgc3BlYzoge1xuICAgICAgICB0eXBlczogc2NoZW1hc1xuICAgICAgfSxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnNwZWMudHlwZXM7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSB0eXBlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50eXBlRXJyb3IodHVwbGUubm90VHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgX2Nhc3QoaW5wdXRWYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVzXG4gICAgfSA9IHRoaXMuc3BlYztcbiAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLl9jYXN0KGlucHV0VmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgY2FzdEFycmF5ID0gdHlwZXMubWFwKCh0eXBlLCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RFbGVtZW50ID0gdHlwZS5jYXN0KHZhbHVlW2lkeF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgcGF0aDogYCR7b3B0aW9ucy5wYXRoIHx8ICcnfVske2lkeH1dYFxuICAgICAgfSkpO1xuICAgICAgaWYgKGNhc3RFbGVtZW50ICE9PSB2YWx1ZVtpZHhdKSBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNhc3RFbGVtZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBpc0NoYW5nZWQgPyBjYXN0QXJyYXkgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IGl0ZW1UeXBlcyA9IHRoaXMuc3BlYy50eXBlcztcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKHR1cGxlRXJyb3JzLCB2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTI7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCByZXNwZWN0aW5nIHJlY3Vyc2l2ZVxuICAgICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICAgIG5leHQodHVwbGVFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRlc3RzID0gW107XG4gICAgICBmb3IgKGxldCBbaW5kZXgsIGl0ZW1TY2hlbWFdIG9mIGl0ZW1UeXBlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTtcbiAgICAgICAgdGVzdHNbaW5kZXhdID0gaXRlbVNjaGVtYS5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUgOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRlc3RzLFxuICAgICAgICBvcmlnaW5hbFZhbHVlOiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgOiBfdmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBpbm5lclR5cGVFcnJvcnMgPT4gbmV4dChpbm5lclR5cGVFcnJvcnMuY29uY2F0KHR1cGxlRXJyb3JzKSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgYmFzZS5pbm5lclR5cGUgPSBuZXh0LnNwZWMudHlwZXMubWFwKChzY2hlbWEsIGluZGV4KSA9PiB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9ucztcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtpbmRleF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQxLnByb3RvdHlwZSA9IFR1cGxlU2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlKGJ1aWxkZXIpIHtcbiAgcmV0dXJuIG5ldyBMYXp5KGJ1aWxkZXIpO1xufVxuZnVuY3Rpb24gY2F0Y2hWYWxpZGF0aW9uRXJyb3IoZm4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuY2xhc3MgTGF6eSB7XG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXIpIHtcbiAgICB0aGlzLnR5cGUgPSAnbGF6eSc7XG4gICAgdGhpcy5fX2lzWXVwU2NoZW1hX18gPSB0cnVlO1xuICAgIHRoaXMuc3BlYyA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZXNvbHZlID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmJ1aWxkZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFpc1NjaGVtYShzY2hlbWEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXp5KCkgZnVuY3Rpb25zIG11c3QgcmV0dXJuIGEgdmFsaWQgc2NoZW1hJyk7XG4gICAgICBpZiAodGhpcy5zcGVjLm9wdGlvbmFsKSBzY2hlbWEgPSBzY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgIHJldHVybiBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcbiAgICB9O1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgdGhpcy5zcGVjID0ge1xuICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IG5ldyBMYXp5KHRoaXMuYnVpbGRlcik7XG4gICAgbmV4dC5zcGVjID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zcGVjLCBzcGVjKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbGl0eShvcHRpb25hbCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIG9wdGlvbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkodHJ1ZSk7XG4gIH1cbiAgcmVzb2x2ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUob3B0aW9ucy52YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5jYXN0KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBhc05lc3RlZFRlc3QoY29uZmlnKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGluZGV4LFxuICAgICAgcGFyZW50LFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSBjb25maWc7XG4gICAgbGV0IHZhbHVlID0gcGFyZW50W2luZGV4ICE9IG51bGwgPyBpbmRleCA6IGtleV07XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgcGFyZW50XG4gICAgfSkpLmFzTmVzdGVkVGVzdChjb25maWcpO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNhdGNoVmFsaWRhdGlvbkVycm9yKCgpID0+IHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBjYXRjaFZhbGlkYXRpb25FcnJvcigoKSA9PiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZUF0KHBhdGgsIHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLmlzVmFsaWQodmFsdWUsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLmlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykuZGVzY3JpYmUob3B0aW9ucykgOiB7XG4gICAgICB0eXBlOiAnbGF6eScsXG4gICAgICBtZXRhOiB0aGlzLnNwZWMubWV0YSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG4gIG1ldGEoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuc3BlYy5tZXRhO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5tZXRhID0gT2JqZWN0LmFzc2lnbihuZXh0LnNwZWMubWV0YSB8fCB7fSwgYXJnc1swXSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgZ2V0IFsnfnN0YW5kYXJkJ10oKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcztcbiAgICBjb25zdCBzdGFuZGFyZCA9IHtcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICB2ZW5kb3I6ICd5dXAnLFxuICAgICAgYXN5bmMgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEudmFsaWRhdGUodmFsdWUsIHtcbiAgICAgICAgICAgIGFib3J0RWFybHk6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaXNzdWVzOiBpc3N1ZXNGcm9tVmFsaWRhdGlvbkVycm9yKGVycilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN0YW5kYXJkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExvY2FsZShjdXN0b20pIHtcbiAgT2JqZWN0LmtleXMoY3VzdG9tKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3Qua2V5cyhjdXN0b21bdHlwZV0pLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxvY2FsZVt0eXBlXVttZXRob2RdID0gY3VzdG9tW3R5cGVdW21ldGhvZF07XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRNZXRob2Qoc2NoZW1hVHlwZSwgbmFtZSwgZm4pIHtcbiAgaWYgKCFzY2hlbWFUeXBlIHx8ICFpc1NjaGVtYShzY2hlbWFUeXBlLnByb3RvdHlwZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB5dXAgc2NoZW1hIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgTWV0aG9kIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXRob2QgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCcpO1xuICBzY2hlbWFUeXBlLnByb3RvdHlwZVtuYW1lXSA9IGZuO1xufVxuXG5leHBvcnQgeyBBcnJheVNjaGVtYSwgQm9vbGVhblNjaGVtYSwgRGF0ZVNjaGVtYSwgTGF6eSBhcyBMYXp5U2NoZW1hLCBNaXhlZFNjaGVtYSwgTnVtYmVyU2NoZW1hLCBPYmplY3RTY2hlbWEsIFNjaGVtYSwgU3RyaW5nU2NoZW1hLCBUdXBsZVNjaGVtYSwgVmFsaWRhdGlvbkVycm9yLCBhZGRNZXRob2QsIGNyZWF0ZSQyIGFzIGFycmF5LCBjcmVhdGUkNyBhcyBib29sLCBjcmVhdGUkNyBhcyBib29sZWFuLCBjcmVhdGUkNCBhcyBkYXRlLCBsb2NhbGUgYXMgZGVmYXVsdExvY2FsZSwgZ2V0SW4sIGlzU2NoZW1hLCBjcmVhdGUgYXMgbGF6eSwgY3JlYXRlJDggYXMgbWl4ZWQsIGNyZWF0ZSQ1IGFzIG51bWJlciwgY3JlYXRlJDMgYXMgb2JqZWN0LCBwcmludFZhbHVlLCByZWFjaCwgY3JlYXRlJDkgYXMgcmVmLCBzZXRMb2NhbGUsIGNyZWF0ZSQ2IGFzIHN0cmluZywgY3JlYXRlJDEgYXMgdHVwbGUgfTtcbiJdLCJuYW1lcyI6WyJnZXR0ZXIiLCJmb3JFYWNoIiwic3BsaXQiLCJub3JtYWxpemVQYXRoIiwiam9pbiIsImNhbWVsQ2FzZSIsInNuYWtlQ2FzZSIsInRvcG9zb3J0IiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJlcnJvclRvU3RyaW5nIiwiRXJyb3IiLCJyZWdFeHBUb1N0cmluZyIsIlJlZ0V4cCIsInN5bWJvbFRvU3RyaW5nIiwiU3ltYm9sIiwiU1lNQk9MX1JFR0VYUCIsInByaW50TnVtYmVyIiwidmFsIiwiaXNOZWdhdGl2ZVplcm8iLCJwcmludFNpbXBsZVZhbHVlIiwicXVvdGVTdHJpbmdzIiwidHlwZU9mIiwibmFtZSIsImNhbGwiLCJyZXBsYWNlIiwidGFnIiwic2xpY2UiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsInByaW50VmFsdWUiLCJ2YWx1ZSIsInJlc3VsdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJ0b0FycmF5IiwiY29uY2F0IiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIl9TeW1ib2wkaGFzSW5zdGFuY2UiLCJfU3ltYm9sJHRvU3RyaW5nVGFnMiIsInN0clJlZyIsInRvU3RyaW5nVGFnIiwiVmFsaWRhdGlvbkVycm9yTm9TdGFjayIsImNvbnN0cnVjdG9yIiwiZXJyb3JPckVycm9ycyIsImZpZWxkIiwidHlwZSIsIm1lc3NhZ2UiLCJwYXRoIiwicGFyYW1zIiwiZXJyb3JzIiwiaW5uZXIiLCJlcnIiLCJWYWxpZGF0aW9uRXJyb3IiLCJpc0Vycm9yIiwicHVzaCIsImlubmVyRXJyb3JzIiwibGVuZ3RoIiwiaGFzSW5zdGFuY2UiLCJmb3JtYXRFcnJvciIsImxhYmVsIiwiYXNzaWduIiwib3JpZ2luYWxQYXRoIiwiXyIsImRpc2FibGVTdGFjayIsImVycm9yTm9TdGFjayIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW5zdCIsIm1peGVkIiwiZGVmYXVsdCIsInJlcXVpcmVkIiwiZGVmaW5lZCIsIm5vdE51bGwiLCJvbmVPZiIsIm5vdE9uZU9mIiwibm90VHlwZSIsIm9yaWdpbmFsVmFsdWUiLCJjYXN0TXNnIiwic3RyaW5nIiwibWluIiwibWF4IiwibWF0Y2hlcyIsImVtYWlsIiwidXJsIiwidXVpZCIsImRhdGV0aW1lIiwiZGF0ZXRpbWVfcHJlY2lzaW9uIiwiZGF0ZXRpbWVfb2Zmc2V0IiwidHJpbSIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsIm51bWJlciIsImxlc3NUaGFuIiwibW9yZVRoYW4iLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwiaW50ZWdlciIsImRhdGUiLCJib29sZWFuIiwiaXNWYWx1ZSIsIm9iamVjdCIsIm5vVW5rbm93biIsImV4YWN0IiwiYXJyYXkiLCJ0dXBsZSIsInNwZWMiLCJ0eXBlTGVuIiwidHlwZXMiLCJBcnJheSIsImlzQXJyYXkiLCJsb2NhbGUiLCJjcmVhdGUiLCJpc1NjaGVtYSIsIm9iaiIsIl9faXNZdXBTY2hlbWFfXyIsIkNvbmRpdGlvbiIsImZyb21PcHRpb25zIiwicmVmcyIsImNvbmZpZyIsInRoZW4iLCJvdGhlcndpc2UiLCJUeXBlRXJyb3IiLCJpcyIsImNoZWNrIiwidmFsdWVzIiwiZXZlcnkiLCJzY2hlbWEiLCJfYnJhbmNoIiwiYnJhbmNoIiwiYnVpbGRlciIsImZuIiwicmVzb2x2ZSIsImJhc2UiLCJvcHRpb25zIiwibWFwIiwicmVmIiwiZ2V0VmFsdWUiLCJwYXJlbnQiLCJjb250ZXh0IiwidW5kZWZpbmVkIiwicHJlZml4ZXMiLCJjcmVhdGUkOSIsIlJlZmVyZW5jZSIsImlzQ29udGV4dCIsImlzU2libGluZyIsInByZWZpeCIsImNhc3QiLCJkZXNjcmliZSIsImlzUmVmIiwiX19pc1l1cFJlZiIsImlzQWJzZW50IiwiY3JlYXRlVmFsaWRhdGlvbiIsInZhbGlkYXRlIiwicGFuaWMiLCJuZXh0IiwidGVzdCIsInNraXBBYnNlbnQiLCJhYm9ydEVhcmx5IiwiZGlzYWJsZVN0YWNrVHJhY2UiLCJyZXNvbHZlT3B0aW9ucyIsImNyZWF0ZUVycm9yIiwib3ZlcnJpZGVzIiwibmV4dFBhcmFtcyIsInJlc29sdmVQYXJhbXMiLCJlcnJvciIsImludmFsaWQiLCJjdHgiLCJmcm9tIiwiaXRlbSIsInJlc29sdmVNYXliZVJlZiIsImhhbmRsZVJlc3VsdCIsInZhbGlkT3JFcnJvciIsImhhbmRsZUVycm9yIiwic2hvdWxkU2tpcCIsIl9yZXN1bHQiLCJzeW5jIiwiUHJvbWlzZSIsIk9QVElPTlMiLCJrZXlzIiwiZ2V0SW4iLCJsYXN0UGFydCIsImxhc3RQYXJ0RGVidWciLCJwYXJlbnRQYXRoIiwiX3BhcnQiLCJpc0JyYWNrZXQiLCJwYXJ0IiwiaXNUdXBsZSIsImlkeCIsInBhcnNlSW50IiwiaW5uZXJUeXBlIiwiZmllbGRzIiwicmVhY2giLCJSZWZlcmVuY2VTZXQiLCJTZXQiLCJkZXNjcmlwdGlvbiIsInJlc29sdmVBbGwiLCJjbG9uZSIsIm1lcmdlIiwibmV3SXRlbXMiLCJyZW1vdmVJdGVtcyIsImFkZCIsImRlbGV0ZSIsInNyYyIsInNlZW4iLCJNYXAiLCJoYXMiLCJnZXQiLCJjb3B5IiwiRGF0ZSIsInNldCIsImkiLCJrIiwidiIsImVudHJpZXMiLCJjcmVhdGVTdGFuZGFyZFBhdGgiLCJzZWdtZW50cyIsImN1cnJlbnRTZWdtZW50IiwiaW5CcmFja2V0cyIsImluUXVvdGVzIiwiY2hhciIsImZpbHRlciIsIkJvb2xlYW4iLCJjcmVhdGVTdGFuZGFyZElzc3VlcyIsImlzc3Vlc0Zyb21WYWxpZGF0aW9uRXJyb3IiLCJfZXJyb3IkaW5uZXIiLCJmbGF0TWFwIiwiU2NoZW1hIiwiZGVwcyIsInRlc3RzIiwidHJhbnNmb3JtcyIsImNvbmRpdGlvbnMiLCJfbXV0YXRlIiwiaW50ZXJuYWxUZXN0cyIsIl93aGl0ZWxpc3QiLCJfYmxhY2tsaXN0IiwiZXhjbHVzaXZlVGVzdHMiLCJfdHlwZUNoZWNrIiwid2l0aE11dGF0aW9uIiwidHlwZUVycm9yIiwic3RyaXAiLCJzdHJpY3QiLCJyZWN1cnNpdmUiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwiY29lcmNlIiwicyIsIm5vbk51bGxhYmxlIiwiX3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIm1ldGEiLCJhcmdzIiwiYmVmb3JlIiwiY29tYmluZWQiLCJtZXJnZWRTcGVjIiwiaXNUeXBlIiwicmVkdWNlIiwicHJldlNjaGVtYSIsImNvbmRpdGlvbiIsIl9vcHRpb25zJHN0cmljdCIsIl9vcHRpb25zJGFib3J0RWFybHkiLCJfb3B0aW9ucyRyZWN1cnNpdmUiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2siLCJyZXNvbHZlZFNjaGVtYSIsImFsbG93T3B0aW9uYWxpdHkiLCJhc3NlcnQiLCJfY2FzdCIsImZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVkUmVzdWx0IiwicmF3VmFsdWUiLCJwcmV2VmFsdWUiLCJnZXREZWZhdWx0IiwiX3ZhbGlkYXRlIiwiX3ZhbHVlIiwiaW5pdGlhbFRlc3RzIiwicnVuVGVzdHMiLCJpbml0aWFsRXJyb3JzIiwicnVuT3B0aW9ucyIsImZpcmVkIiwicGFuaWNPbmNlIiwiYXJnIiwibmV4dE9uY2UiLCJjb3VudCIsIm5lc3RlZEVycm9ycyIsImZpbmlzaFRlc3RSdW4iLCJhc05lc3RlZFRlc3QiLCJpbmRleCIsIm9yaWdpbmFsUGFyZW50IiwiaXNJbmRleCIsInRlc3RPcHRpb25zIiwiaW5jbHVkZXMiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2syIiwicmVqZWN0IiwicGFyc2VkIiwidmFsaWRhdGVkIiwidmFsaWRhdGVTeW5jIiwiX29wdGlvbnMkZGlzYWJsZVN0YWNrMyIsImlzVmFsaWQiLCJpc1ZhbGlkU3luYyIsIl9nZXREZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwiZGVmIiwiYXJndW1lbnRzIiwiaXNTdHJpY3QiLCJudWxsYWJpbGl0eSIsIm9wdGlvbmFsaXR5Iiwibm90UmVxdWlyZWQiLCJ0cmFuc2Zvcm0iLCJvcHRzIiwiaXNFeGNsdXNpdmUiLCJleGNsdXNpdmUiLCJ3aGVuIiwiZGVwIiwiZW51bXMiLCJ3aGl0ZUxpc3QiLCJ2YWxpZHMiLCJyZXNvbHZlZCIsImJsYWNrbGlzdCIsImludmFsaWRzIiwibiIsImxpc3QiLCJmaW5kSW5kZXgiLCJjIiwic3RhbmRhcmQiLCJ2ZXJzaW9uIiwidmVuZG9yIiwiaXNzdWVzIiwibWV0aG9kIiwiYWxpYXMiLCJyZXR1cm5zVHJ1ZSIsImNyZWF0ZSQ4IiwiTWl4ZWRTY2hlbWEiLCJjcmVhdGUkNyIsIkJvb2xlYW5TY2hlbWEiLCJ2YWx1ZU9mIiwiX3JhdyIsIlN0cmluZyIsImlzVHJ1ZSIsImlzRmFsc2UiLCJtc2ciLCJpc29SZWciLCJwYXJzZUlzb0RhdGUiLCJzdHJ1Y3QiLCJwYXJzZURhdGVTdHJ1Y3QiLCJwYXJzZSIsIk51bWJlciIsIk5hTiIsInoiLCJwbHVzTWludXMiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJ0b3RhbE1pbnV0ZXNPZmZzZXQiLCJob3VyT2Zmc2V0IiwibWludXRlT2Zmc2V0IiwiVVRDIiwiX3JlZ2V4UmVzdWx0JDckbGVuZ3RoIiwiX3JlZ2V4UmVzdWx0JCIsInJlZ2V4UmVzdWx0IiwiZXhlYyIsInRvTnVtYmVyIiwic3Vic3RyaW5nIiwicHJlY2lzaW9uIiwic3RyIiwickVtYWlsIiwiclVybCIsInJVVUlEIiwieWVhck1vbnRoRGF5IiwiaG91ck1pbnV0ZVNlY29uZCIsInpPck9mZnNldCIsInJJc29EYXRlVGltZSIsImlzVHJpbW1lZCIsIm9ialN0cmluZ1RhZyIsImNyZWF0ZSQ2IiwiU3RyaW5nU2NoZW1hIiwic3RyVmFsdWUiLCJ0IiwicmVnZXgiLCJleGNsdWRlRW1wdHlTdHJpbmciLCJzZWFyY2giLCJhbGxvd09mZnNldCIsImVuc3VyZSIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJpc05hTiQxIiwiY3JlYXRlJDUiLCJOdW1iZXJTY2hlbWEiLCJwYXJzZUZsb2F0IiwibGVzcyIsIm1vcmUiLCJpc0ludGVnZXIiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiX21ldGhvZCIsImF2YWlsIiwiaW5kZXhPZiIsIk1hdGgiLCJpbnZhbGlkRGF0ZSIsImlzRGF0ZSIsImNyZWF0ZSQ0IiwiRGF0ZVNjaGVtYSIsIklOVkFMSURfREFURSIsInByZXBhcmVQYXJhbSIsInBhcmFtIiwibGltaXQiLCJzb3J0RmllbGRzIiwiZXhjbHVkZWRFZGdlcyIsImVkZ2VzIiwibm9kZXMiLCJleGNsdWRlcyIsImEiLCJiIiwiYWRkTm9kZSIsImRlcFBhdGgiLCJub2RlIiwicmV2ZXJzZSIsImFyciIsIkluZmluaXR5Iiwic29tZSIsImlpIiwiX2VyciRwYXRoIiwic29ydEJ5S2V5T3JkZXIiLCJwYXJzZUpzb24iLCJkZWVwUGFydGlhbCIsInBhcnRpYWwiLCJmaWVsZFNjaGVtYSIsInNldEZpZWxkcyIsIm5leHRBcnJheSIsImRlZXBIYXMiLCJwIiwibGFzdCIsInBvcCIsImlzT2JqZWN0IiwidW5rbm93biIsImtub3duIiwiZGVmYXVsdFNvcnQiLCJjcmVhdGUkMyIsIk9iamVjdFNjaGVtYSIsIl9zb3J0RXJyb3JzIiwiX25vZGVzIiwiX2V4Y2x1ZGVkRWRnZXMiLCJzaGFwZSIsIl9vcHRpb25zJHN0cmlwVW5rbm93biIsInN0cmlwVW5rbm93biIsInByb3BzIiwiaW50ZXJtZWRpYXRlVmFsdWUiLCJpbm5lck9wdGlvbnMiLCJfX3ZhbGlkYXRpbmciLCJpc0NoYW5nZWQiLCJwcm9wIiwiZXhpc3RzIiwiZmllbGRWYWx1ZSIsImlucHV0VmFsdWUiLCJmaWVsZFNwZWMiLCJvYmplY3RFcnJvcnMiLCJmaWVsZEVycm9ycyIsInNvcnQiLCJuZXh0RmllbGRzIiwic2NoZW1hT3JSZWYiLCJ0YXJnZXQiLCJkZnQiLCJfaW5uZXJPcHRpb25zIiwiYWRkaXRpb25zIiwiRnVuY3Rpb24iLCJwaWNrIiwicGlja2VkIiwib21pdCIsInJlbWFpbmluZyIsInRvIiwiZnJvbUdldHRlciIsIm5ld09iaiIsImpzb24iLCJ1bmtub3duS2V5cyIsInByb3BlcnRpZXMiLCJub0FsbG93IiwiYWxsb3ciLCJ0cmFuc2Zvcm1LZXlzIiwiY29uc3RhbnRDYXNlIiwiX2lubmVyT3B0aW9uczIiLCJjcmVhdGUkMiIsIkFycmF5U2NoZW1hIiwiX29wdHMiLCJjYXN0QXJyYXkiLCJjYXN0RWxlbWVudCIsImFycmF5RXJyb3JzIiwiX29wdGlvbnMkb3JpZ2luYWxWYWx1MiIsIl9vcHRpb25zJG9yaWdpbmFsVmFsdSIsImlubmVyVHlwZUVycm9ycyIsIm9mIiwib3JpZ2luYWwiLCJjb21wYWN0IiwicmVqZWN0b3IiLCJjcmVhdGUkMSIsInNjaGVtYXMiLCJUdXBsZVNjaGVtYSIsIml0ZW1UeXBlcyIsInR1cGxlRXJyb3JzIiwiaXRlbVNjaGVtYSIsIkxhenkiLCJjYXRjaFZhbGlkYXRpb25FcnJvciIsIl9yZXNvbHZlIiwidmFsaWRhdGVBdCIsInZhbGlkYXRlU3luY0F0Iiwic2V0TG9jYWxlIiwiY3VzdG9tIiwiYWRkTWV0aG9kIiwic2NoZW1hVHlwZSIsIkxhenlTY2hlbWEiLCJib29sIiwiZGVmYXVsdExvY2FsZSIsImxhenkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/yup/index.esm.js\n");

/***/ })

};
;